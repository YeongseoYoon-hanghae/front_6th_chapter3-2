# 스토리 1.2: 주간 요일별 날짜 계산 로직 구현

## 스토리 개요

**As a** 개발자  
**I want** 선택된 요일들만 포함하는 주간 반복 날짜를 계산할 수 있다  
**So that** 사용자가 선택한 특정 요일에만 일정이 생성될 수 있다

## 비즈니스 컨텍스트

### 현재 상태

- `calculateRecurringDates` 함수가 주간 반복을 7일 간격으로만 계산
- 매주 같은 요일에만 반복 가능 (월요일 → 월요일)
- 사용자가 원하는 복수 요일 선택 불가능

### 목표 상태

- WeeklyOptions를 활용한 새로운 계산 함수 추가
- 선택된 요일들만 포함하는 날짜 배열 생성
- 기존 함수와의 완전한 하위 호환성 유지

### 사용자 시나리오

```typescript
// 사용자 요구사항: "매주 월, 수, 금요일에 운동"
const weeklyOptions = { daysOfWeek: [1, 3, 5] }; // 월, 수, 금
const dates = calculateWeeklyWithSpecificDays(
  '2024-01-01', // 시작일 (월요일)
  '2024-01-31', // 종료일
  1, // 매주
  weeklyOptions
);
// 결과: ['2024-01-01', '2024-01-03', '2024-01-05', '2024-01-08', '2024-01-10', '2024-01-12', ...]
```

## 수락 기준

### AC1: calculateWeeklyWithSpecificDays 함수 구현

**Given** 주간 반복에서 특정 요일들을 선택했을 때  
**When** 날짜 계산을 수행할 때  
**Then** 선택된 요일에만 해당하는 날짜들이 반환되어야 한다

**함수 시그니처:**

```typescript
function calculateWeeklyWithSpecificDays(
  startDate: string,
  endDate: string,
  interval: number,
  weeklyOptions: WeeklyOptions
): string[];
```

**검증 기준:**

- [ ] 선택된 요일에만 해당하는 날짜가 생성됨
- [ ] 시작일이 선택된 요일이 아니면 다음 선택된 요일부터 시작
- [ ] interval 간격에 따라 주 단위로 반복됨
- [ ] endDate를 초과하지 않음
- [ ] 빈 daysOfWeek 배열에 대해 빈 배열 반환

### AC2: calculateRecurringDatesWithOptions 함수 구현

**Given** RepeatInfo에 weeklyOptions가 포함된 경우  
**When** 반복 날짜 계산을 수행할 때  
**Then** weeklyOptions를 고려한 날짜가 계산되어야 한다

**함수 시그니처:**

```typescript
function calculateRecurringDatesWithOptions(
  startDate: string,
  endDate: string,
  repeatType: RepeatType,
  repeatInterval: number,
  weeklyOptions?: WeeklyOptions
): string[];
```

**검증 기준:**

- [ ] weeklyOptions가 있고 repeatType이 'weekly'면 새로운 로직 사용
- [ ] weeklyOptions가 없으면 기존 `calculateRecurringDates` 함수 호출
- [ ] 다른 repeatType에서는 weeklyOptions 무시
- [ ] 모든 입력 유효성 검사 수행

### AC3: 기존 함수 호환성 유지

**Given** 기존 `calculateRecurringDates` 함수가 있을 때  
**When** 새로운 함수들이 추가될 때  
**Then** 기존 함수는 변경 없이 동작해야 한다

**검증 기준:**

- [ ] 기존 함수 시그니처 및 동작 완전 유지
- [ ] 기존 테스트 케이스 모두 통과
- [ ] 기존 호출 코드 변경 없이 동작
- [ ] 성능 특성 유지

### AC4: 종합 단위 테스트 통과

**Given** 모든 계산 함수들이 구현되었을 때  
**When** 다양한 요일 조합에 대해 테스트할 때  
**Then** 모든 테스트 케이스가 통과해야 한다

**검증 기준:**

- [ ] 단일 요일 선택 케이스 통과
- [ ] 복수 요일 선택 케이스 통과
- [ ] 모든 요일 선택 케이스 통과
- [ ] 경계값 테스트 케이스 통과
- [ ] 에러 케이스 처리 확인

## 통합 검증 기준

### IV1: 기존 주간 반복 계산 호환성

**검증 시나리오:**

```typescript
// 기존 방식 - 변경 없이 동작해야 함
const dates = calculateRecurringDates('2024-01-01', '2024-01-15', 'weekly', 1);
expect(dates).toEqual(['2024-01-01', '2024-01-08', '2024-01-15']);
```

### IV2: 새로운 계산 로직 성능 특성

**검증 기준:**

- 기존 주간 반복 대비 성능 저하 20% 이하
- 메모리 사용량 유의미한 증가 없음
- 대용량 날짜 범위에서 안정적 동작

### IV3: 다양한 요일 조합 정확성

**검증 시나리오:**

- 평일만 선택 (월~금)
- 주말만 선택 (토, 일)
- 격일 선택 (월, 수, 금)
- 연속 요일 선택 (목, 금, 토)

## 기술적 구현 요구사항

### 구현 파일

- **주 파일**: `src/utils/recurringUtils.ts`
- **테스트 파일**: `src/__tests__/unit/recurringUtils.test.ts`

### 핵심 함수 구현

#### 1. calculateWeeklyWithSpecificDays 함수

```typescript
/**
 * 주간 반복에서 특정 요일들만 선택하여 날짜를 계산합니다.
 * @param startDate 시작일 (YYYY-MM-DD 형식)
 * @param endDate 종료일 (YYYY-MM-DD 형식)
 * @param interval 주 간격 (1 이상의 정수)
 * @param weeklyOptions 선택된 요일 정보
 * @returns 계산된 날짜 배열 (YYYY-MM-DD 형식)
 */
export function calculateWeeklyWithSpecificDays(
  startDate: string,
  endDate: string,
  interval: number,
  weeklyOptions: WeeklyOptions
): string[] {
  // 1. 유효성 검사
  if (interval <= 0 || weeklyOptions.daysOfWeek.length === 0) {
    return [];
  }

  const start = new Date(startDate);
  const end = new Date(endDate);
  const maxEnd = new Date(MAX_END_DATE);

  if (start > end || start > maxEnd) {
    return [];
  }

  const actualEnd = end > maxEnd ? maxEnd : end;
  const selectedDays = [...weeklyOptions.daysOfWeek].sort();
  const dates: string[] = [];

  // 2. 시작 주에서 선택된 요일들 찾기
  let currentWeekStart = new Date(start);
  currentWeekStart.setDate(start.getDate() - start.getDay()); // 주의 시작(일요일)

  while (currentWeekStart <= actualEnd) {
    // 3. 현재 주에서 선택된 요일들 처리
    for (const dayOfWeek of selectedDays) {
      const currentDate = new Date(currentWeekStart);
      currentDate.setDate(currentWeekStart.getDate() + dayOfWeek);

      // 4. 날짜 범위 검증 및 추가
      if (currentDate >= start && currentDate <= actualEnd) {
        dates.push(formatDate(currentDate));
      }
    }

    // 5. 다음 주로 이동 (interval 고려)
    currentWeekStart.setDate(currentWeekStart.getDate() + interval * 7);
  }

  return dates;
}
```

#### 2. calculateRecurringDatesWithOptions 함수

```typescript
/**
 * WeeklyOptions를 지원하는 반복 날짜 계산 함수
 * @param startDate 시작일
 * @param endDate 종료일
 * @param repeatType 반복 타입
 * @param repeatInterval 반복 간격
 * @param weeklyOptions 주간 옵션 (선택사항)
 * @returns 계산된 날짜 배열
 */
export function calculateRecurringDatesWithOptions(
  startDate: string,
  endDate: string,
  repeatType: RepeatType,
  repeatInterval: number,
  weeklyOptions?: WeeklyOptions
): string[] {
  // weeklyOptions가 있고 주간 반복인 경우
  if (repeatType === 'weekly' && weeklyOptions) {
    return calculateWeeklyWithSpecificDays(startDate, endDate, repeatInterval, weeklyOptions);
  }

  // 기존 로직 사용
  return calculateRecurringDates(startDate, endDate, repeatType, repeatInterval);
}
```

#### 3. generateRepeatEventsWithOptions 함수

```typescript
/**
 * WeeklyOptions를 지원하는 반복 일정 생성 함수
 * @param eventData 원본 일정 데이터 (weeklyOptions 포함 가능)
 * @returns 생성된 반복 일정 배열
 */
export function generateRepeatEventsWithOptions(eventData: EventForm): EventForm[] {
  if (eventData.repeat.type === 'none' || eventData.repeat.interval === 0) {
    return [eventData];
  }

  const endDate = eventData.repeat.endDate || MAX_END_DATE;
  const weeklyOptions = eventData.repeat.weeklyOptions;

  const dates = calculateRecurringDatesWithOptions(
    eventData.date,
    endDate,
    eventData.repeat.type,
    eventData.repeat.interval,
    weeklyOptions
  );

  return dates.map((date) => ({
    ...eventData,
    date: date,
  }));
}
```

## 테스트 전략

### 단위 테스트 케이스

#### 1. calculateWeeklyWithSpecificDays 테스트

```typescript
describe('calculateWeeklyWithSpecificDays', () => {
  describe('기본 동작', () => {
    it('단일 요일 선택 시 정확한 날짜 반환', () => {
      const result = calculateWeeklyWithSpecificDays(
        '2024-01-01', // 월요일
        '2024-01-15',
        1,
        { daysOfWeek: [1] } // 월요일만
      );
      expect(result).toEqual(['2024-01-01', '2024-01-08', '2024-01-15']);
    });

    it('복수 요일 선택 시 정확한 날짜 반환', () => {
      const result = calculateWeeklyWithSpecificDays(
        '2024-01-01', // 월요일
        '2024-01-07',
        1,
        { daysOfWeek: [1, 3, 5] } // 월, 수, 금
      );
      expect(result).toEqual(['2024-01-01', '2024-01-03', '2024-01-05']);
    });

    it('시작일이 선택된 요일이 아닌 경우', () => {
      const result = calculateWeeklyWithSpecificDays(
        '2024-01-02', // 화요일
        '2024-01-10',
        1,
        { daysOfWeek: [1, 5] } // 월, 금만
      );
      expect(result).toEqual(['2024-01-05', '2024-01-08']); // 금요일부터 시작
    });

    it('interval 간격으로 주 반복', () => {
      const result = calculateWeeklyWithSpecificDays(
        '2024-01-01', // 월요일
        '2024-01-29',
        2, // 격주
        { daysOfWeek: [1] } // 월요일
      );
      expect(result).toEqual(['2024-01-01', '2024-01-15', '2024-01-29']);
    });
  });

  describe('경계값 및 에러 케이스', () => {
    it('빈 요일 배열에 대해 빈 배열 반환', () => {
      const result = calculateWeeklyWithSpecificDays('2024-01-01', '2024-01-07', 1, {
        daysOfWeek: [],
      });
      expect(result).toEqual([]);
    });

    it('유효하지 않은 interval에 대해 빈 배열 반환', () => {
      const result = calculateWeeklyWithSpecificDays('2024-01-01', '2024-01-07', 0, {
        daysOfWeek: [1],
      });
      expect(result).toEqual([]);
    });

    it('시작일이 종료일보다 늦은 경우 빈 배열 반환', () => {
      const result = calculateWeeklyWithSpecificDays('2024-01-15', '2024-01-01', 1, {
        daysOfWeek: [1],
      });
      expect(result).toEqual([]);
    });

    it('MAX_END_DATE 이후로는 날짜 생성 안함', () => {
      const result = calculateWeeklyWithSpecificDays('2025-10-01', '2025-12-31', 1, {
        daysOfWeek: [1],
      });
      // 2025-10-30 이후 날짜는 포함되지 않아야 함
      expect(result.every((date) => date <= '2025-10-30')).toBe(true);
    });
  });

  describe('다양한 요일 조합', () => {
    it('평일만 선택 (월~금)', () => {
      const result = calculateWeeklyWithSpecificDays(
        '2024-01-01', // 월요일
        '2024-01-07',
        1,
        { daysOfWeek: [1, 2, 3, 4, 5] }
      );
      expect(result).toEqual([
        '2024-01-01',
        '2024-01-02',
        '2024-01-03',
        '2024-01-04',
        '2024-01-05',
      ]);
    });

    it('주말만 선택 (토, 일)', () => {
      const result = calculateWeeklyWithSpecificDays(
        '2024-01-01', // 월요일
        '2024-01-07',
        1,
        { daysOfWeek: [0, 6] } // 일, 토
      );
      expect(result).toEqual(['2024-01-06', '2024-01-07']);
    });

    it('모든 요일 선택', () => {
      const result = calculateWeeklyWithSpecificDays('2024-01-01', '2024-01-07', 1, {
        daysOfWeek: [0, 1, 2, 3, 4, 5, 6],
      });
      expect(result).toHaveLength(7);
    });
  });
});
```

#### 2. calculateRecurringDatesWithOptions 테스트

```typescript
describe('calculateRecurringDatesWithOptions', () => {
  it('weeklyOptions가 있는 주간 반복', () => {
    const result = calculateRecurringDatesWithOptions('2024-01-01', '2024-01-15', 'weekly', 1, {
      daysOfWeek: [1, 5],
    });
    expect(result).toEqual(['2024-01-01', '2024-01-05', '2024-01-08', '2024-01-12', '2024-01-15']);
  });

  it('weeklyOptions가 없는 주간 반복은 기존 로직 사용', () => {
    const result = calculateRecurringDatesWithOptions('2024-01-01', '2024-01-15', 'weekly', 1);
    expect(result).toEqual(['2024-01-01', '2024-01-08', '2024-01-15']);
  });

  it('주간이 아닌 반복 타입에서는 weeklyOptions 무시', () => {
    const result = calculateRecurringDatesWithOptions('2024-01-01', '2024-01-05', 'daily', 1, {
      daysOfWeek: [1],
    });
    // 매일 반복으로 동작해야 함
    expect(result).toEqual(['2024-01-01', '2024-01-02', '2024-01-03', '2024-01-04', '2024-01-05']);
  });
});
```

#### 3. generateRepeatEventsWithOptions 테스트

```typescript
describe('generateRepeatEventsWithOptions', () => {
  const baseEvent: EventForm = {
    title: 'Test Event',
    date: '2024-01-01',
    startTime: '09:00',
    endTime: '10:00',
    description: '',
    location: '',
    category: '',
    repeat: { type: 'weekly', interval: 1 },
    notificationTime: 10,
  };

  it('weeklyOptions가 있는 반복 일정 생성', () => {
    const eventWithOptions = {
      ...baseEvent,
      repeat: {
        ...baseEvent.repeat,
        endDate: '2024-01-15',
        weeklyOptions: { daysOfWeek: [1, 5] },
      },
    };

    const result = generateRepeatEventsWithOptions(eventWithOptions);
    expect(result).toHaveLength(4); // 1일(월), 5일(금), 8일(월), 12일(금)
    expect(result.map((e) => e.date)).toEqual([
      '2024-01-01',
      '2024-01-05',
      '2024-01-08',
      '2024-01-12',
    ]);
  });

  it('weeklyOptions가 없는 일정은 기존 방식으로 생성', () => {
    const eventWithoutOptions = {
      ...baseEvent,
      repeat: {
        ...baseEvent.repeat,
        endDate: '2024-01-15',
      },
    };

    const result = generateRepeatEventsWithOptions(eventWithoutOptions);
    expect(result).toHaveLength(3); // 1일, 8일, 15일
    expect(result.map((e) => e.date)).toEqual(['2024-01-01', '2024-01-08', '2024-01-15']);
  });
});
```

### 통합 테스트 케이스

#### 1. 기존 함수와의 호환성 테스트

```typescript
describe('Backward Compatibility', () => {
  it('기존 calculateRecurringDates 함수 동작 유지', () => {
    const existingResult = calculateRecurringDates('2024-01-01', '2024-01-15', 'weekly', 1);
    const newResult = calculateRecurringDatesWithOptions('2024-01-01', '2024-01-15', 'weekly', 1);
    expect(newResult).toEqual(existingResult);
  });

  it('기존 generateRepeatEvents 함수와 일치', () => {
    const baseEvent: EventForm = {
      title: 'Test',
      date: '2024-01-01',
      startTime: '09:00',
      endTime: '10:00',
      description: '',
      location: '',
      category: '',
      repeat: { type: 'weekly', interval: 1, endDate: '2024-01-15' },
      notificationTime: 10,
    };

    const existingResult = generateRepeatEvents(baseEvent);
    const newResult = generateRepeatEventsWithOptions(baseEvent);
    expect(newResult).toEqual(existingResult);
  });
});
```

#### 2. 성능 테스트

```typescript
describe('Performance', () => {
  it('대용량 날짜 범위 처리 성능', () => {
    const startTime = performance.now();

    calculateWeeklyWithSpecificDays(
      '2024-01-01',
      '2025-12-31',
      1,
      { daysOfWeek: [1, 2, 3, 4, 5] } // 평일
    );

    const endTime = performance.now();
    expect(endTime - startTime).toBeLessThan(100); // 100ms 이하
  });

  it('기존 함수 대비 성능 저하 20% 이하', () => {
    const iterations = 1000;

    // 기존 함수 성능 측정
    const start1 = performance.now();
    for (let i = 0; i < iterations; i++) {
      calculateRecurringDates('2024-01-01', '2024-12-31', 'weekly', 1);
    }
    const time1 = performance.now() - start1;

    // 새로운 함수 성능 측정
    const start2 = performance.now();
    for (let i = 0; i < iterations; i++) {
      calculateRecurringDatesWithOptions('2024-01-01', '2024-12-31', 'weekly', 1);
    }
    const time2 = performance.now() - start2;

    expect(time2).toBeLessThanOrEqual(time1 * 1.2); // 20% 이하 성능 저하
  });
});
```

## 완료 정의 (Definition of Done)

### 기능 완료 기준

- [ ] calculateWeeklyWithSpecificDays 함수 구현 완료
- [ ] calculateRecurringDatesWithOptions 함수 구현 완료
- [ ] generateRepeatEventsWithOptions 함수 구현 완료
- [ ] 모든 함수에 JSDoc 주석 추가

### 품질 기준

- [ ] 모든 단위 테스트 통과 (90% 이상 커버리지)
- [ ] 통합 테스트 통과
- [ ] 기존 함수 호환성 검증 완료
- [ ] 성능 요구사항 충족 (20% 이하 성능 저하)

### 문서화 기준

- [ ] 함수별 상세 JSDoc 주석 작성
- [ ] 사용 예시 코드 작성
- [ ] 아키텍처 문서 업데이트

### 검토 기준

- [ ] 코드 리뷰 승인
- [ ] 알고리즘 설계 검토 완료
- [ ] 테스트 케이스 검토 완료

## 위험 요소 및 완화 전략

### 위험 요소

1. **복잡한 날짜 계산 로직**: 요일 변환 및 주간 반복 계산의 복잡성
2. **성능 저하**: 새로운 계산 로직으로 인한 성능 영향
3. **경계값 처리**: 월 경계, 연도 경계에서의 정확성

### 완화 전략

1. **철저한 테스트**: TDD 방식으로 다양한 시나리오 검증
2. **알고리즘 최적화**: 효율적인 날짜 계산 알고리즘 적용
3. **기존 로직 재사용**: 검증된 기존 함수 최대한 활용

## 다음 스토리와의 연계

이 스토리 완료 후:

- **스토리 1.3**: 계산된 날짜를 표시하는 UI 컴포넌트에서 활용
- **스토리 1.4**: RepeatSection에서 새로운 계산 함수 통합

## 리뷰 체크리스트

### 알고리즘 정확성

- [ ] 요일 변환 로직이 정확함 (0=일요일, 6=토요일)
- [ ] 주간 반복 계산이 정확함
- [ ] 시작일과 종료일 경계 처리가 정확함

### 성능 최적화

- [ ] 불필요한 날짜 객체 생성 최소화
- [ ] 반복문 최적화
- [ ] 메모리 사용량 최적화

### 호환성 보장

- [ ] 기존 함수 동작 변경 없음
- [ ] 새로운 함수는 기존 패턴 준수
- [ ] 타입 정의와 일치하는 구현

---

이 스토리는 주간 반복 요일 선택 기능의 핵심 로직을 구현하며, 기존 시스템과의 완전한 호환성을 보장하면서 새로운 기능을 제공합니다.

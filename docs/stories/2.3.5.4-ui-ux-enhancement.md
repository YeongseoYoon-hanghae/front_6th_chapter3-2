# Story 2.3.5.4: 단일 수정 모드 UI/UX 개선

## Status

Ready for Development

## Story

**As a** 캘린더 사용자,  
**I want** 반복 일정을 단일 수정할 때 현재 모드를 명확히 알 수 있는 UI를,  
**so that** 어떤 일정이 어떻게 수정될지 이해하고 안심하고 사용할 수 있다.

## Problem Statement

현재 단일 수정 모드에서:

1. **모드 구분 불가** - 일반 편집과 단일 수정을 구분할 수 없음
2. **사용자 혼란** - 반복 설정을 보고 모든 일정이 수정될까 걱정함
3. **안내 부족** - 반복 설정을 해제하면 어떻게 되는지 명확하지 않음
4. **피드백 부족** - 저장 후 어떤 일정이 어떻게 변경되었는지 알기 어려움

## Acceptance Criteria

1. **모드 안내 메시지** - 단일 수정 모드임을 명확히 알려주는 안내문 표시
2. **반복 설정 설명** - 반복 설정 변경 시 영향 범위 설명
3. **시각적 구분** - 단일 수정 모드임을 나타내는 시각적 표시
4. **저장 후 피드백** - 저장 완료 시 어떤 일정이 수정되었는지 명확한 메시지
5. **일관된 UX** - 다른 반복 일정 기능과 일관된 사용자 경험

## Technical Solution

### 1. EventForm 컴포넌트에 모드 안내 추가

```typescript
// src/components/EventForm.tsx - 단일 수정 모드 안내
const EventForm = ({ editingEvent, isSingleEdit, onSave, onCancel }) => {
  return (
    <Box>
      {/* 단일 수정 모드 안내 헤더 */}
      {editingEvent && isSingleEdit && (
        <Alert severity="info" sx={{ mb: 2 }}>
          <AlertTitle>이 일정만 수정</AlertTitle>
          반복 일정에서 이 날짜의 일정만 수정됩니다. 다른 날짜의 동일한 반복 일정은 영향받지 않습니다.
        </Alert>
      )}

      {/* 기존 폼 필드들 */}
      <Stack spacing={3}>
        {/* 제목, 날짜, 시간 등 기본 필드 */}

        {/* 반복 일정 체크박스 */}
        <FormControlLabel
          control={
            <Checkbox checked={isRepeating} onChange={(e) => setIsRepeating(e.target.checked)} />
          }
          label={
            <Box>
              반복 일정
              {editingEvent && isSingleEdit && (
                <Typography variant="caption" color="text.secondary" display="block">
                  반복 설정을 해제하면 단일 일정으로 저장됩니다.
                </Typography>
              )}
            </Box>
          }
        />

        {/* 반복 설정 필드들 */}
        {isRepeating && (
          <Box
            sx={{
              border: isSingleEdit ? '1px dashed' : '1px solid',
              borderColor: 'divider',
              borderRadius: 1,
              p: 2,
              bgcolor: isSingleEdit ? 'action.hover' : 'transparent',
            }}
          >
            {isSingleEdit && (
              <Typography variant="body2" color="info.main" sx={{ mb: 2 }}>
                💡 원본 반복 설정을 참고용으로 표시합니다. 변경사항은 이 일정에만 적용됩니다.
              </Typography>
            )}

            {/* 반복 유형, 간격, 종료일 필드들 */}
            <Stack spacing={2}>{/* ... 기존 반복 설정 필드들 ... */}</Stack>
          </Box>
        )}
      </Stack>

      {/* 저장/취소 버튼 */}
      <Box sx={{ mt: 3, display: 'flex', gap: 2, justifyContent: 'flex-end' }}>
        <Button variant="outlined" onClick={onCancel}>
          취소
        </Button>
        <Button variant="contained" onClick={onSave} color={isSingleEdit ? 'warning' : 'primary'}>
          {isSingleEdit ? '이 일정만 저장' : editingEvent ? '수정' : '추가'}
        </Button>
      </Box>
    </Box>
  );
};
```

### 2. 폼 헤더에 모드 표시

```typescript
// src/components/EventForm.tsx - 폼 제목 개선
const getFormTitle = (editingEvent: Event | null, isSingleEdit: boolean) => {
  if (!editingEvent) return '새 일정 추가';
  if (isSingleEdit) return '반복 일정 단일 수정';
  return '일정 수정';
};

const getFormIcon = (isSingleEdit: boolean) => {
  return isSingleEdit ? <EditIcon color="warning" /> : <EventIcon />;
};
```

### 3. 저장 완료 알림 메시지 개선

```typescript
// src/App.tsx - 모드별 성공 메시지
const addOrUpdateEvent = async () => {
  try {
    // ... 저장 로직 ...

    // 성공 시 모드별 메시지
    if (isSingleEdit) {
      addNotification(
        `${formatDate(eventData.date)}의 "${eventData.title}" 일정이 단일 일정으로 수정되었습니다.`,
        'success'
      );
    } else if (editingEvent) {
      addNotification('일정이 수정되었습니다.', 'success');
    } else {
      addNotification('일정이 추가되었습니다.', 'success');
    }
  } catch (error) {
    // 에러 메시지도 모드별로 구분
    if (isSingleEdit) {
      addNotification('단일 일정 수정에 실패했습니다.', 'error');
    } else {
      addNotification('일정 저장에 실패했습니다.', 'error');
    }
  }
};
```

### 4. 확인 다이얼로그 개선

```typescript
// src/components/RecurringEditDialog.tsx - 설명 개선
const RecurringEditDialog = ({ isOpen, targetEvent, onEditSingle, onCancel }) => {
  return (
    <Dialog open={isOpen} onClose={onCancel}>
      <DialogTitle>
        <Box display="flex" alignItems="center" gap={1}>
          <RepeatIcon color="primary" />
          반복 일정 수정
        </Box>
      </DialogTitle>

      <DialogContent>
        <Typography variant="body1" sx={{ mb: 2 }}>
          "{targetEvent?.title}" 반복 일정을 어떻게 수정하시겠습니까?
        </Typography>

        <Stack spacing={2}>
          <Card variant="outlined" sx={{ p: 2 }}>
            <Typography variant="subtitle2" color="warning.main">
              이 일정만 수정
            </Typography>
            <Typography variant="body2" color="text.secondary">
              {formatDate(targetEvent?.date)}의 일정만 수정됩니다. 다른 날짜의 동일한 반복 일정은
              변경되지 않습니다.
            </Typography>
          </Card>

          <Card variant="outlined" sx={{ p: 2 }}>
            <Typography variant="subtitle2" color="primary.main">
              모든 반복 일정 수정
            </Typography>
            <Typography variant="body2" color="text.secondary">
              전체 반복 일정 시리즈가 수정됩니다. (향후 구현 예정)
            </Typography>
          </Card>
        </Stack>
      </DialogContent>

      <DialogActions>
        <Button onClick={onCancel}>취소</Button>
        <Button onClick={onEditSingle} variant="contained" color="warning" startIcon={<EditIcon />}>
          이 일정만 수정
        </Button>
      </DialogActions>
    </Dialog>
  );
};
```

## Implementation Tasks

- [ ] **EventForm 컴포넌트 UI 개선**

  - [ ] 단일 수정 모드 안내 Alert 추가
  - [ ] 반복 설정 필드 시각적 구분 (테두리, 배경색)
  - [ ] 반복 체크박스 설명 텍스트 추가
  - [ ] 저장 버튼 텍스트 및 색상 변경

- [ ] **폼 헤더 개선**

  - [ ] 모드별 제목 표시 함수 구현
  - [ ] 모드별 아이콘 표시
  - [ ] 시각적 구분을 위한 스타일링

- [ ] **알림 메시지 개선**

  - [ ] 모드별 성공 메시지 구현
  - [ ] 모드별 에러 메시지 구현
  - [ ] 날짜 포맷팅 유틸리티 활용

- [ ] **RecurringEditDialog 개선**
  - [ ] 선택지별 상세 설명 추가
  - [ ] 시각적 카드 형태로 옵션 표시
  - [ ] 아이콘 및 색상으로 모드 구분

## Test Cases

### Test 1: 단일 수정 모드 안내 표시

```typescript
test('단일 수정 모드에서 안내 메시지가 표시됨', () => {
  render(<EventForm editingEvent={mockRecurringEvent} isSingleEdit={true} />);

  expect(screen.getByText('이 일정만 수정')).toBeInTheDocument();
  expect(screen.getByText(/반복 일정에서 이 날짜의 일정만 수정됩니다/)).toBeInTheDocument();
});
```

### Test 2: 반복 설정 필드 시각적 구분

```typescript
test('단일 수정 모드에서 반복 설정 필드가 시각적으로 구분됨', () => {
  render(<EventForm editingEvent={mockRecurringEvent} isSingleEdit={true} isRepeating={true} />);

  const repeatSection = screen.getByText('원본 반복 설정을 참고용으로 표시합니다').closest('div');
  expect(repeatSection).toHaveStyle({
    border: '1px dashed',
    'background-color': expect.any(String),
  });
});
```

### Test 3: 저장 버튼 텍스트 변경

```typescript
test('단일 수정 모드에서 저장 버튼 텍스트가 변경됨', () => {
  render(<EventForm editingEvent={mockRecurringEvent} isSingleEdit={true} />);

  expect(screen.getByText('이 일정만 저장')).toBeInTheDocument();
  expect(screen.queryByText('수정')).not.toBeInTheDocument();
});
```

### Test 4: 성공 메시지 표시

```typescript
test('단일 수정 완료 시 적절한 성공 메시지가 표시됨', async () => {
  const { addNotification } = renderHook(() => useNotifications());

  // 단일 수정 저장 시뮬레이션
  await addOrUpdateEvent({
    title: '팀 회의',
    date: '2024-12-20',
    isSingleEdit: true,
  });

  expect(addNotification).toHaveBeenCalledWith(
    '2024년 12월 20일의 "팀 회의" 일정이 단일 일정으로 수정되었습니다.',
    'success'
  );
});
```

## Definition of Done

- [ ] 단일 수정 모드 안내 메시지 표시됨
- [ ] 반복 설정 필드가 시각적으로 구분됨
- [ ] 저장 버튼이 모드에 따라 다르게 표시됨
- [ ] 모드별 성공/에러 메시지 구현됨
- [ ] RecurringEditDialog 선택지 설명 개선됨
- [ ] 모든 UI 컴포넌트 테스트 통과
- [ ] 접근성 검증 완료
- [ ] 디자인 시스템 일관성 확인

## Dependencies

**전제 조건:**

- Story 2.3.5.1 (단일 수정 모드 상태 관리 개선) 완료
- Story 2.3.5.2 (폼 로딩 로직 수정) 완료
- Story 2.3.5.3 (제출 로직 개선) 완료

**UI 라이브러리:**

- Material-UI Alert, Card, Typography 컴포넌트
- 기존 알림 시스템 (`useNotifications`)

## Estimated Effort

**개발 시간:** 3-4시간  
**디자인 조정:** 1-2시간  
**테스트 시간:** 2시간  
**총 예상 시간:** 6-8시간

## Notes

이 스토리는 사용자 경험을 크게 개선하는 중요한 UI/UX 작업입니다. 기능적으로는 완성되었지만 사용자가 안심하고 사용할 수 있도록 하는 마지막 퍼즐 조각입니다.

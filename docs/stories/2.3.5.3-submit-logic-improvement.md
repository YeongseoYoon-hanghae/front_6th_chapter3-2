# Story 2.3.5.3: 단일 수정 모드 제출 로직 개선

## Status

Ready for Development

## Story

**As a** 캘린더 사용자,  
**I want** 반복 일정을 단일 수정할 때 제출 시점에만 단일 일정으로 전환되기를,  
**so that** 폼에서는 원본 정보를 보면서도 저장할 때는 단일 일정으로 처리된다.

## Problem Statement

현재 폼 로딩 시점에 `convertToSingleEvent`가 실행되어:

1. **제출 시점에 단일 전환을 할 수 없음** - 이미 반복 정보가 제거됨
2. **단일 수정 모드 구분 불가** - 일반 수정과 동일하게 처리됨
3. **API 호출 로직 혼재** - 반복 배치 생성과 단일 수정이 명확히 분리되지 않음

## Acceptance Criteria

1. **제출 시점 전환** - 폼 제출 시에만 `convertToSingleEvent` 호출
2. **모드 구분 처리** - `isSingleEdit` 플래그에 따른 조건부 처리
3. **API 호출 분리** - 단일 수정 모드에서는 반복 배치 생성 로직 건너뛰기
4. **데이터 무결성** - 원본 반복 그룹에 영향 없이 단일 일정만 생성
5. **기존 로직 보존** - 일반 편집 모드는 기존과 동일하게 동작

## Technical Solution

### 1. addOrUpdateEvent 함수 수정

```typescript
// src/App.tsx - 현재 구현
const addOrUpdateEvent = async () => {
  try {
    // ... 기존 유효성 검사 ...

    let eventData: Event | EventFormType = {
      id: editingEvent ? editingEvent.id : undefined,
      title,
      date,
      startTime,
      endTime,
      description,
      location,
      category,
      repeat: {
        type: isRepeating ? repeatType : 'none',
        interval: repeatInterval,
        endDate: repeatEndDate || undefined,
      },
      notificationTime,
    };

    // 현재: 항상 동일한 로직
    if (editingEvent) {
      await updateEvent(eventData);
    } else {
      await saveEvent(eventData);
    }
  } catch (error) {
    // ...
  }
};
```

```typescript
// src/App.tsx - 수정된 구현
const addOrUpdateEvent = async () => {
  try {
    // ... 기존 유효성 검사 ...

    let eventData: Event | EventFormType = {
      id: editingEvent ? editingEvent.id : undefined,
      title,
      date,
      startTime,
      endTime,
      description,
      location,
      category,
      repeat: {
        type: isRepeating ? repeatType : 'none',
        interval: repeatInterval,
        endDate: repeatEndDate || undefined,
      },
      notificationTime,
    };

    // ✅ 개선: 단일 수정 모드 처리
    if (editingEvent) {
      if (isSingleEdit) {
        // 단일 수정: 반복 정보 제거 후 새 일정으로 생성
        const singleEventData = convertToSingleEvent(eventData);
        await saveEvent(singleEventData);
      } else {
        // 일반 수정: 기존 로직
        await updateEvent(eventData);
      }
    } else {
      await saveEvent(eventData);
    }

    // ... 후처리 로직 ...
  } catch (error) {
    // ...
  }
};
```

### 2. 반복 배치 생성 로직 분리

```typescript
// src/App.tsx - saveEvent 함수 개선
const saveEvent = async (eventData: Event | EventFormType) => {
  if (eventData.repeat.type !== 'none' && !isSingleEdit) {
    // 반복 일정이고 단일 수정이 아닌 경우만 배치 생성
    const events = generateRecurringEvents(eventData);
    for (const event of events) {
      await createEvent(event);
    }
  } else {
    // 단일 일정 또는 단일 수정인 경우
    await createEvent(eventData);
  }
};
```

### 3. 상태 정리 로직 개선

```typescript
// src/App.tsx - 편집 완료 후 상태 정리
const addOrUpdateEvent = async () => {
  try {
    // ... 이벤트 저장 로직 ...

    // 성공 시 상태 정리
    stopEditing(); // isSingleEdit 플래그도 함께 리셋
    resetForm();

    // 알림 표시
    if (isSingleEdit) {
      addNotification('반복 일정에서 이 일정만 수정되었습니다.', 'success');
    } else if (editingEvent) {
      addNotification('일정이 수정되었습니다.', 'success');
    } else {
      addNotification('일정이 추가되었습니다.', 'success');
    }
  } catch (error) {
    // ... 에러 처리 ...
  }
};
```

## Implementation Tasks

- [ ] **addOrUpdateEvent 함수 수정**

  - [ ] `isSingleEdit` 플래그 확인 로직 추가
  - [ ] 단일 수정 모드에서 `convertToSingleEvent` 호출
  - [ ] 단일 수정 시 `saveEvent` 호출로 새 일정 생성

- [ ] **saveEvent 함수 개선**

  - [ ] 단일 수정 모드에서 반복 배치 생성 건너뛰기
  - [ ] 조건부 로직으로 `generateRecurringEvents` 호출 제어

- [ ] **상태 정리 로직 추가**

  - [ ] 성공 시 `stopEditing()` 호출로 모든 편집 상태 리셋
  - [ ] 모드별 적절한 알림 메시지 표시

- [ ] **에러 처리 개선**
  - [ ] 단일 수정 실패 시 적절한 에러 메시지
  - [ ] 원본 반복 그룹 보호 로직

## Test Cases

### Test 1: 단일 수정 모드에서 convertToSingleEvent 호출

```typescript
test('단일 수정 모드에서 제출 시 convertToSingleEvent가 호출됨', async () => {
  const convertSpy = jest.spyOn(recurringUtils, 'convertToSingleEvent');

  const recurringEvent = {
    id: '1',
    title: '팀 회의',
    repeat: { type: 'weekly', interval: 1 },
  };

  render(<App />);

  // 단일 수정 모드 시작
  act(() => {
    startSingleEdit(recurringEvent);
  });

  // 폼 제출
  const saveButton = screen.getByText('저장');
  fireEvent.click(saveButton);

  await waitFor(() => {
    expect(convertSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        title: '팀 회의',
        repeat: expect.objectContaining({ type: 'weekly' }),
      })
    );
  });
});
```

### Test 2: 단일 수정 시 새 일정 생성

```typescript
test('단일 수정 시 updateEvent가 아닌 saveEvent가 호출됨', async () => {
  const updateEventSpy = jest.spyOn(eventOperations, 'updateEvent');
  const saveEventSpy = jest.spyOn(eventOperations, 'saveEvent');

  const recurringEvent = {
    id: '1',
    title: '팀 회의',
    repeat: { type: 'weekly' },
  };

  render(<App />);

  // 단일 수정 모드에서 제목 변경 후 저장
  act(() => {
    startSingleEdit(recurringEvent);
  });

  const titleInput = screen.getByLabelText('제목');
  fireEvent.change(titleInput, { target: { value: '긴급 팀 회의' } });

  const saveButton = screen.getByText('저장');
  fireEvent.click(saveButton);

  await waitFor(() => {
    expect(updateEventSpy).not.toHaveBeenCalled();
    expect(saveEventSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        title: '긴급 팀 회의',
        repeat: { type: 'none' }, // convertToSingleEvent 적용됨
      })
    );
  });
});
```

### Test 3: 일반 수정 모드 동작 유지

```typescript
test('일반 수정 모드는 기존과 동일하게 updateEvent 호출', async () => {
  const updateEventSpy = jest.spyOn(eventOperations, 'updateEvent');
  const convertSpy = jest.spyOn(recurringUtils, 'convertToSingleEvent');

  const singleEvent = {
    id: '1',
    title: '개인 약속',
    repeat: { type: 'none' },
  };

  render(<App />);

  // 일반 수정 모드
  act(() => {
    startEdit(singleEvent);
  });

  const saveButton = screen.getByText('저장');
  fireEvent.click(saveButton);

  await waitFor(() => {
    expect(updateEventSpy).toHaveBeenCalled();
    expect(convertSpy).not.toHaveBeenCalled();
  });
});
```

### Test 4: 단일 수정 후 상태 정리

```typescript
test('단일 수정 완료 후 편집 상태가 정리됨', async () => {
  const { result } = renderHook(() => useEditingState());

  const recurringEvent = {
    id: '1',
    repeat: { type: 'weekly' },
  };

  // 단일 수정 시작
  act(() => {
    result.current.startSingleEdit(recurringEvent);
  });

  expect(result.current.isSingleEdit).toBe(true);

  // 저장 후 상태 확인
  // (실제 구현에서는 addOrUpdateEvent 성공 시 stopEditing 호출)
  act(() => {
    result.current.stopEditing();
  });

  expect(result.current.isSingleEdit).toBe(false);
  expect(result.current.isEditing).toBe(false);
});
```

## Definition of Done

- [ ] 단일 수정 모드에서 제출 시에만 `convertToSingleEvent` 호출됨
- [ ] `isSingleEdit` 플래그에 따른 조건부 처리 구현됨
- [ ] 단일 수정 시 새 일정 생성 (`saveEvent` 호출)
- [ ] 일반 수정 모드는 기존 동작 유지 (`updateEvent` 호출)
- [ ] 모든 단위 테스트 통과
- [ ] 편집 완료 후 상태 정리 확인
- [ ] 코드 리뷰 완료

## Dependencies

**전제 조건:**

- Story 2.3.5.1 (단일 수정 모드 상태 관리 개선) 완료
- Story 2.3.5.2 (폼 로딩 로직 수정) 완료
- 기존 `convertToSingleEvent` 함수 구현 완료

**연관 스토리:**

- Story 2.3.3 (단일 수정 PUT API 연동) - API 계층 연동
- Story 2.3.4 (반복 그룹 무결성 및 캘린더 업데이트) - 저장 후 처리

## Estimated Effort

**개발 시간:** 3-4시간  
**테스트 시간:** 2-3시간  
**총 예상 시간:** 5-7시간

## Notes

이 스토리는 반복 일정 단일 수정의 핵심 로직을 담당합니다. 폼 표시와 실제 저장 로직을 분리하여 사용자 경험과 데이터 처리를 모두 만족시키는 중요한 구현입니다.

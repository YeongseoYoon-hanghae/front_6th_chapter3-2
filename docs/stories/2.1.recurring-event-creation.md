# Story 2.1: 반복 일정 생성

## Status

Draft

## Story

**As a** 캘린더 사용자,
**I want** 반복 유형과 종료 조건을 설정하여 반복 일정을 생성하고,
**so that** 반복되는 일정을 매번 입력하지 않아도 된다.

## Acceptance Criteria

1. 반복 유형(매일, 매주, 매월, 매년)을 선택할 수 있다
2. 반복 종료 날짜를 설정할 수 있다 (최대 2025-10-30)
3. 31일 매월 선택 시 31일에만 생성된다
4. 윤년 29일 매년 선택 시 29일에만 생성된다
5. 배치 API를 통해 모든 반복 인스턴스가 생성된다

## Tasks / Subtasks

- [ ] **반복 일정 UI 활성화** (AC: 1,2)

  - [ ] 일정 폼에서 반복 일정 체크박스 주석 해제
  - [ ] 반복 유형 선택 드롭다운 구현 (매일, 매주, 매월, 매년)
  - [ ] 반복 종료 날짜 입력 필드 구현
  - [ ] 2025-10-30 최대 제한 검증 로직 추가

- [ ] **반복 날짜 계산 로직 구현** (AC: 3,4)

  - [ ] 매일 반복: 기본 날짜 증가 로직
  - [ ] 매주 반복: 7일 간격 계산 로직
  - [ ] 매월 반복: 31일 특수 규칙 구현 (31일에만 생성)
  - [ ] 매년 반복: 윤년 29일 특수 규칙 구현 (29일에만 생성)
  - [ ] 반복 종료 조건 처리 (endDate까지)

- [ ] **배치 API 통합** (AC: 5)

  - [ ] POST `/api/events-list` 엔드포인트 활용
  - [ ] 반복 그룹 ID 생성 및 할당
  - [ ] 배치 요청 페이로드 구성
  - [ ] 배치 응답 처리 및 에러 핸들링

- [ ] **반복 로직 서비스 개발**
  - [ ] useRecurringEvents 커스텀 훅 구현
  - [ ] RecurringEventManager 서비스 클래스 구현
  - [ ] 반복 관련 유틸리티 함수 구현

## Dev Notes

### 기술적 구현 세부사항

**새로운 컴포넌트 구조:**

```typescript
// 새로운 커스텀 훅
export const useRecurringEvents = () => {
  const generateRecurringDates = (startDate: string, repeatInfo: RepeatInfo): string[] => {
    // 반복 유형별 날짜 계산 로직
  };

  const createRecurringEvents = async (eventForm: EventForm, recurringDates: string[]) => {
    // 배치 API 호출
  };

  return { generateRecurringDates, createRecurringEvents };
};
```

**확장된 데이터 모델:**

```typescript
// src/types.ts 확장
export interface Event extends EventForm {
  id: string;
  repeat: RepeatInfo & {
    id?: string; // 반복 그룹 ID (새로 추가)
  };
}

export interface RepeatInfo {
  type: 'none' | 'daily' | 'weekly' | 'monthly' | 'yearly';
  interval: number;
  endDate?: string; // YYYY-MM-DD 형식
  endCondition: 'date';
  id?: string; // 반복 그룹 ID
}
```

**반복 날짜 계산 로직:**

```typescript
// src/utils/recurringUtils.ts (새로 생성)
export const calculateRecurringDates = (
  startDate: string,
  repeatType: RepeatInfo['type'],
  endDate: string
): string[] => {
  const dates: string[] = [];
  const start = new Date(startDate);
  const end = new Date(endDate);
  const maxEnd = new Date('2025-10-30');

  // 최대 종료일 제한
  const actualEnd = end > maxEnd ? maxEnd : end;

  let current = new Date(start);

  while (current <= actualEnd) {
    dates.push(current.toISOString().split('T')[0]);

    switch (repeatType) {
      case 'daily':
        current.setDate(current.getDate() + 1);
        break;
      case 'weekly':
        current.setDate(current.getDate() + 7);
        break;
      case 'monthly':
        // 31일 특수 처리
        if (start.getDate() === 31) {
          current = getNextMonthWithDate31(current);
        } else {
          current.setMonth(current.getMonth() + 1);
        }
        break;
      case 'yearly':
        // 윤년 2/29 특수 처리
        if (start.getMonth() === 1 && start.getDate() === 29) {
          current = getNextLeapYear(current);
        } else {
          current.setFullYear(current.getFullYear() + 1);
        }
        break;
    }
  }

  return dates;
};
```

**배치 API 통합:**

```typescript
// useEventOperations 확장
const createRecurringEvents = async (baseEvent: EventForm, dates: string[]): Promise<Event[]> => {
  const repeatId = crypto.randomUUID();

  const events = dates.map((date) => ({
    ...baseEvent,
    date,
    repeat: {
      ...baseEvent.repeat,
      id: repeatId,
    },
  }));

  const response = await fetch('/api/events-list', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ events }),
  });

  return response.json();
};
```

### 파일 경로 (새로 생성)

- `src/hooks/useRecurringEvents.ts` - 반복 일정 전용 훅
- `src/utils/recurringUtils.ts` - 반복 날짜 계산 로직
- `src/services/RecurringEventManager.ts` - 반복 일정 비즈니스 로직

### 파일 경로 (기존 확장)

- `src/App.tsx` - 반복 UI 활성화
- `src/types.ts` - RepeatInfo 타입 확장
- `src/hooks/useEventForm.ts` - 반복 폼 상태 관리 추가
- `src/hooks/useEventOperations.ts` - 배치 API 연동 추가

### 특수 날짜 규칙 구현

**31일 매월 반복:**

```typescript
const getNextMonthWithDate31 = (current: Date): Date => {
  let next = new Date(current);
  do {
    next.setMonth(next.getMonth() + 1);
    // 31일이 없는 달인 경우 다음 달로 넘어감
    if (next.getDate() !== 31) {
      next.setDate(31);
    }
  } while (next.getDate() !== 31);
  return next;
};
```

**윤년 2/29 매년 반복:**

```typescript
const getNextLeapYear = (current: Date): Date => {
  let year = current.getFullYear() + 1;
  while (!isLeapYear(year)) {
    year++;
  }
  return new Date(year, 1, 29); // 2월 29일
};
```

### 성능 고려사항

- 반복 일정 생성 시간: 1초 이내 (최대 100개 인스턴스)
- 메모리 효율적인 날짜 계산 (대량 배열 생성 최소화)
- 배치 API 타임아웃 설정: 10초

### 에러 처리

- 최대 종료일 초과 시 경고 메시지
- 배치 API 실패 시 롤백 처리
- 잘못된 반복 설정 시 검증 에러 표시

## Testing

### Unit Tests

- [ ] 반복 날짜 계산 로직 테스트

  - [ ] 매일 반복 정확성 테스트
  - [ ] 매주 반복 정확성 테스트
  - [ ] 매월 반복 (31일 규칙) 테스트
  - [ ] 매년 반복 (윤년 29일 규칙) 테스트
  - [ ] 최대 종료일 제한 테스트

- [ ] 반복 그룹 ID 생성 테스트
- [ ] 특수 날짜 규칙 함수 테스트
- [ ] 반복 폼 검증 로직 테스트

### Integration Tests

- [ ] POST `/api/events-list` API 호출 테스트
- [ ] 배치 생성 후 캘린더 업데이트 테스트
- [ ] 반복 일정 생성 전체 플로우 테스트
- [ ] 배치 API 에러 응답 처리 테스트

### E2E Tests

- [ ] 반복 일정 UI 설정 및 생성 전체 플로우
- [ ] 매일/매주/매월/매년 각각의 생성 테스트
- [ ] 31일 및 윤년 특수 케이스 생성 테스트

## Definition of Done

### 기능적 요구사항

- [ ] 반복 설정 UI가 일정 폼에 활성화
- [ ] 모든 반복 유형별 날짜 계산 로직 정확히 구현
- [ ] 특수 날짜 규칙 (31일, 윤년) 정확히 처리
- [ ] POST `/api/events-list` API 연동 완료
- [ ] 반복 그룹 ID 생성 및 할당 로직 구현

### 기술적 요구사항

- [ ] 반복 일정 생성 시간 1초 이내 (최대 100개)
- [ ] 반복 로직 단위 테스트 100% 통과
- [ ] TypeScript 타입 안전성 100% 유지
- [ ] 메모리 누수 없음

### 품질 요구사항

- [ ] Material-UI 디자인 일관성 유지
- [ ] 접근성 표준 준수
- [ ] 반응형 디자인 정상 동작
- [ ] 에러 처리 및 사용자 피드백 완성

### 데이터 무결성

- [ ] 반복 그룹 ID 고유성 보장
- [ ] JSON 파일 구조 무결성 유지
- [ ] 기존 단일 일정과의 데이터 호환성

## Project Structure Notes

### 새로 생성되는 파일

```
src/
├── hooks/
│   └── useRecurringEvents.ts      # 반복 일정 전용 훅
├── utils/
│   └── recurringUtils.ts          # 반복 날짜 계산 유틸
└── services/
    └── RecurringEventManager.ts   # 반복 일정 비즈니스 로직
```

### 수정되는 기존 파일

```
src/
├── App.tsx                        # 반복 UI 활성화
├── types.ts                       # RepeatInfo 확장
└── hooks/
    ├── useEventForm.ts            # 반복 폼 상태 추가
    └── useEventOperations.ts      # 배치 API 연동 추가
```

## Change Log

| 날짜       | 변경 사항           | 작성자 |
| ---------- | ------------------- | ------ |
| 2024-12-19 | Story 2.1 초기 생성 | PO     |

## Dependencies

**전제 조건:**

- Story 1.1 (일정 생성 및 관리) 완료
- server.js 업데이트 (POST `/api/events-list` API 추가)
- 기존 RepeatInfo 타입 정의 존재

**블로킹 요소:**

- 배치 API 엔드포인트 구현 완료 필요
- 기존 기능 회귀 테스트 통과 필요

**후속 Story:**

- Story 2.2 (반복 일정 시각적 구분)
- Story 2.3 (반복 일정 단일 수정)
- Story 2.4 (반복 일정 단일 삭제)

이 Story는 반복 일정 기능의 핵심이 되는 가장 중요한 Story로, Epic 2의 모든 후속 Story들의 기반이 됩니다.

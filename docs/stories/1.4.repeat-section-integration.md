# 스토리 1.4: RepeatSection 컴포넌트 통합 및 상태 관리

## 스토리 개요

**As a** 사용자  
**I want** 반복 타입을 주간으로 선택하면 자동으로 요일 선택 UI가 나타난다  
**So that** 직관적으로 주간 반복 요일을 설정할 수 있다

## 비즈니스 컨텍스트

### 현재 상태

- RepeatSection에 기본 반복 설정 필드들만 존재
- 주간 반복 선택 시 추가 옵션 없음
- weeklyOptions 상태 관리 및 폼 통합 없음

### 목표 상태

- 주간 반복 선택 시 WeeklyDaysSelector 자동 표시
- weeklyOptions 상태가 RepeatSection에서 관리됨
- 폼 제출 시 weeklyOptions가 RepeatInfo에 포함됨
- 기존 UI 플로우와 완벽한 통합

### 사용자 플로우

```
1. 사용자가 "반복 일정" 체크박스 선택
2. 반복 유형에서 "매주" 선택
3. WeeklyDaysSelector 자동으로 나타남
4. 사용자가 원하는 요일들 선택 (예: 월, 수, 금)
5. 다른 반복 설정들 (간격, 종료일) 입력
6. 폼 제출 시 모든 설정이 RepeatInfo에 포함됨
```

## 수락 기준

### AC1: 조건부 WeeklyDaysSelector 렌더링

**Given** 사용자가 반복 유형을 변경할 때  
**When** repeatType이 'weekly'로 설정될 때  
**Then** WeeklyDaysSelector가 자동으로 표시되어야 한다

**검증 기준:**

- [ ] repeatType === 'weekly'일 때만 WeeklyDaysSelector 렌더링
- [ ] 다른 반복 타입 선택 시 WeeklyDaysSelector 숨김
- [ ] 애니메이션 없이 즉시 표시/숨김 (성능 고려)
- [ ] RepeatSettings 내 올바른 위치에 표시

### AC2: weeklyOptions 상태 관리

**Given** RepeatSection에서 weeklyOptions를 관리할 때  
**When** 요일 선택이 변경될 때  
**Then** 상위 컴포넌트로 변경사항이 전파되어야 한다

**Props 확장:**

```typescript
interface RepeatSectionProps {
  // 기존 props...
  weeklyOptions?: WeeklyOptions;
  onWeeklyOptionsChange?: (options: WeeklyOptions | undefined) => void;
}
```

**검증 기준:**

- [ ] weeklyOptions prop 추가 (옵셔널)
- [ ] onWeeklyOptionsChange 콜백 추가 (옵셔널)
- [ ] 반복 타입 변경 시 weeklyOptions 상태 적절히 관리
- [ ] 하위 호환성 유지 (기존 사용법 그대로 동작)

### AC3: 반복 타입 변경 시 상태 초기화

**Given** 사용자가 반복 타입을 변경할 때  
**When** 주간이 아닌 다른 타입으로 변경할 때  
**Then** weeklyOptions 상태가 초기화되어야 한다

**검증 기준:**

- [ ] 'weekly' → 다른 타입 변경 시 weeklyOptions undefined로 설정
- [ ] 다른 타입 → 'weekly' 변경 시 weeklyOptions 빈 배열로 초기화
- [ ] 상태 변경 시 onWeeklyOptionsChange 콜백 호출
- [ ] 사용자에게 명확한 피드백 제공

### AC4: 폼 제출 시 RepeatInfo 포함

**Given** 사용자가 주간 반복 설정을 완료했을 때  
**When** 폼이 제출될 때  
**Then** weeklyOptions가 RepeatInfo에 올바르게 포함되어야 한다

**검증 기준:**

- [ ] weeklyOptions가 설정된 경우 RepeatInfo에 포함
- [ ] weeklyOptions가 없는 경우 RepeatInfo에서 제외
- [ ] 빈 배열인 경우 유효성 검증 오류 표시
- [ ] 기존 RepeatInfo 필드들과 함께 올바르게 직렬화

### AC5: 기존 레이아웃과 스타일 일관성

**Given** WeeklyDaysSelector가 RepeatSection에 통합될 때  
**When** 전체 폼이 렌더링될 때  
**Then** 기존 스타일과 일관성 있는 레이아웃이 유지되어야 한다

**검증 기준:**

- [ ] Material-UI Stack spacing 패턴 유지
- [ ] 기존 필드들과 동일한 여백과 간격
- [ ] 반응형 디자인에서 자연스러운 배치
- [ ] 전체 폼의 시각적 균형 유지

## 통합 검증 기준

### IV1: 기존 반복 설정 플로우 호환성

**검증 시나리오:**

```typescript
// 기존 방식 - weeklyOptions 없이 동작
const existingProps = {
  isRepeating: true,
  repeatType: 'weekly' as RepeatType,
  onRepeatTypeChange: (type) => console.log(type),
  // weeklyOptions 관련 props 없음
};
// 정상 렌더링되고 기존 기능 동작해야 함
```

### IV2: 주간 이외 반복 타입 동작

**검증 시나리오:**

- daily, monthly, yearly 선택 시 WeeklyDaysSelector 표시 안됨
- 해당 타입들의 기존 동작 변경 없음
- weeklyOptions 상태가 다른 타입에 영향 없음

### IV3: 폼 상태 관리 일관성

**검증 기준:**

- EventForm에서 RepeatSection 사용 시 weeklyOptions 자동 통합
- 기존 useState 패턴과 일관성 유지
- 부모 컴포넌트에서 weeklyOptions 제어 가능

## 기술적 구현 요구사항

### 구현 파일

- **주 파일**: `src/components/RepeatSection.tsx` (기존 파일 수정)
- **테스트 파일**: `src/__tests__/components/RepeatSection.test.tsx` (기존 파일 확장)

### RepeatSection 컴포넌트 확장

#### Props 인터페이스 확장

```typescript
interface RepeatSectionProps {
  // 기존 props
  isRepeating: boolean;
  onIsRepeatingChange: (isRepeating: boolean) => void;
  repeatType: RepeatType;
  onRepeatTypeChange: (type: RepeatType) => void;
  repeatInterval: number;
  onRepeatIntervalChange: (interval: number) => void;
  repeatEndDate: string;
  onRepeatEndDateChange: (endDate: string) => void;

  // 새로 추가되는 props
  /**
   * 주간 반복 시 선택된 요일 정보
   * repeatType이 'weekly'가 아니면 무시됨
   */
  weeklyOptions?: WeeklyOptions;

  /**
   * 주간 요일 선택 변경 시 호출되는 콜백
   * repeatType이 'weekly'일 때만 호출됨
   */
  onWeeklyOptionsChange?: (options: WeeklyOptions | undefined) => void;

  /**
   * 주간 요일 선택 필드의 검증 오류 메시지
   */
  weeklyOptionsError?: string;
}
```

#### 핵심 로직 구현

```typescript
export const RepeatSection = ({
  isRepeating,
  onIsRepeatingChange,
  repeatType,
  onRepeatTypeChange,
  repeatInterval,
  onRepeatIntervalChange,
  repeatEndDate,
  onRepeatEndDateChange,
  weeklyOptions,
  onWeeklyOptionsChange,
  weeklyOptionsError,
}: RepeatSectionProps) => {
  /**
   * 반복 타입 변경 핸들러
   * 주간 타입 변경 시 weeklyOptions 상태 초기화/설정
   */
  const handleRepeatTypeChange = (newType: RepeatType) => {
    onRepeatTypeChange(newType);

    // weeklyOptions 상태 관리
    if (onWeeklyOptionsChange) {
      if (newType === 'weekly') {
        // 주간으로 변경 시 기본값 설정 (빈 배열)
        if (!weeklyOptions) {
          onWeeklyOptionsChange({ daysOfWeek: [] });
        }
      } else {
        // 다른 타입으로 변경 시 weeklyOptions 제거
        onWeeklyOptionsChange(undefined);
      }
    }
  };

  /**
   * 주간 요일 선택 변경 핸들러
   */
  const handleWeeklyOptionsChange = (selectedDays: number[]) => {
    if (onWeeklyOptionsChange && repeatType === 'weekly') {
      onWeeklyOptionsChange({ daysOfWeek: selectedDays });
    }
  };

  return (
    <Stack spacing={2}>
      <RepeatToggle isRepeating={isRepeating} onToggle={onIsRepeatingChange} />

      {isRepeating && (
        <RepeatSettings
          repeatType={repeatType}
          onRepeatTypeChange={handleRepeatTypeChange}
          repeatInterval={repeatInterval}
          onRepeatIntervalChange={onRepeatIntervalChange}
          repeatEndDate={repeatEndDate}
          onRepeatEndDateChange={onRepeatEndDateChange}
          weeklyOptions={weeklyOptions}
          onWeeklyOptionsChange={handleWeeklyOptionsChange}
          weeklyOptionsError={weeklyOptionsError}
        />
      )}
    </Stack>
  );
};
```

#### RepeatSettings 컴포넌트 확장

```typescript
interface RepeatSettingsProps {
  // 기존 props
  repeatType: RepeatType;
  onRepeatTypeChange: (type: RepeatType) => void;
  repeatInterval: number;
  onRepeatIntervalChange: (interval: number) => void;
  repeatEndDate: string;
  onRepeatEndDateChange: (endDate: string) => void;

  // 새로 추가되는 props
  weeklyOptions?: WeeklyOptions;
  onWeeklyOptionsChange?: (selectedDays: number[]) => void;
  weeklyOptionsError?: string;
}

const RepeatSettings = ({
  repeatType,
  onRepeatTypeChange,
  repeatInterval,
  onRepeatIntervalChange,
  repeatEndDate,
  onRepeatEndDateChange,
  weeklyOptions,
  onWeeklyOptionsChange,
  weeklyOptionsError,
}: RepeatSettingsProps) => (
  <Stack spacing={2}>
    <RepeatTypeField value={repeatType} onChange={onRepeatTypeChange} />

    {/* 주간 반복 시에만 요일 선택 UI 표시 */}
    {repeatType === 'weekly' && onWeeklyOptionsChange && (
      <WeeklyDaysSelector
        selectedDays={weeklyOptions?.daysOfWeek || []}
        onSelectionChange={onWeeklyOptionsChange}
        error={weeklyOptionsError}
        labelId="weekly-days-selector-label"
      />
    )}

    <RepeatIntervalAndEndDate
      interval={repeatInterval}
      onIntervalChange={onRepeatIntervalChange}
      endDate={repeatEndDate}
      onEndDateChange={onRepeatEndDateChange}
    />
  </Stack>
);
```

### EventForm 통합 예시

```typescript
// EventForm.tsx에서 RepeatSection 사용 예시
const EventForm = () => {
  const [formData, setFormData] = useState<EventForm>({
    // ... 기타 필드들
    repeat: {
      type: 'none',
      interval: 1,
      endDate: '',
    },
  });

  const [weeklyOptions, setWeeklyOptions] = useState<WeeklyOptions | undefined>();

  const handleRepeatTypeChange = (type: RepeatType) => {
    setFormData((prev) => ({
      ...prev,
      repeat: { ...prev.repeat, type },
    }));
  };

  const handleWeeklyOptionsChange = (options: WeeklyOptions | undefined) => {
    setWeeklyOptions(options);

    // RepeatInfo에 weeklyOptions 반영
    setFormData((prev) => ({
      ...prev,
      repeat: {
        ...prev.repeat,
        weeklyOptions: options,
      },
    }));
  };

  return (
    <form>
      {/* 다른 필드들... */}

      <RepeatSection
        isRepeating={formData.repeat.type !== 'none'}
        onIsRepeatingChange={(isRepeating) => {
          handleRepeatTypeChange(isRepeating ? 'daily' : 'none');
        }}
        repeatType={formData.repeat.type}
        onRepeatTypeChange={handleRepeatTypeChange}
        repeatInterval={formData.repeat.interval}
        onRepeatIntervalChange={(interval) => {
          setFormData((prev) => ({
            ...prev,
            repeat: { ...prev.repeat, interval },
          }));
        }}
        repeatEndDate={formData.repeat.endDate || ''}
        onRepeatEndDateChange={(endDate) => {
          setFormData((prev) => ({
            ...prev,
            repeat: { ...prev.repeat, endDate },
          }));
        }}
        weeklyOptions={weeklyOptions}
        onWeeklyOptionsChange={handleWeeklyOptionsChange}
      />
    </form>
  );
};
```

## 테스트 전략

### 단위 테스트 케이스

#### 1. 조건부 렌더링 테스트

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { RepeatSection } from '../RepeatSection';

describe('RepeatSection WeeklyDaysSelector 통합', () => {
  const defaultProps = {
    isRepeating: true,
    onIsRepeatingChange: jest.fn(),
    repeatType: 'weekly' as RepeatType,
    onRepeatTypeChange: jest.fn(),
    repeatInterval: 1,
    onRepeatIntervalChange: jest.fn(),
    repeatEndDate: '',
    onRepeatEndDateChange: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('조건부 렌더링', () => {
    it('주간 반복 선택 시 WeeklyDaysSelector 표시', () => {
      render(
        <RepeatSection
          {...defaultProps}
          weeklyOptions={{ daysOfWeek: [] }}
          onWeeklyOptionsChange={jest.fn()}
        />
      );

      expect(screen.getByText('반복 요일')).toBeInTheDocument();
    });

    it('주간이 아닌 반복 타입에서 WeeklyDaysSelector 숨김', () => {
      render(
        <RepeatSection
          {...defaultProps}
          repeatType="daily"
          weeklyOptions={{ daysOfWeek: [] }}
          onWeeklyOptionsChange={jest.fn()}
        />
      );

      expect(screen.queryByText('반복 요일')).not.toBeInTheDocument();
    });

    it('weeklyOptions props가 없으면 WeeklyDaysSelector 표시 안함', () => {
      render(<RepeatSection {...defaultProps} />);
      expect(screen.queryByText('반복 요일')).not.toBeInTheDocument();
    });
  });

  describe('상태 관리', () => {
    it('반복 타입을 주간으로 변경 시 weeklyOptions 초기화', () => {
      const mockOnWeeklyOptionsChange = jest.fn();
      const mockOnRepeatTypeChange = jest.fn();

      render(
        <RepeatSection
          {...defaultProps}
          repeatType="daily"
          onRepeatTypeChange={mockOnRepeatTypeChange}
          onWeeklyOptionsChange={mockOnWeeklyOptionsChange}
        />
      );

      // 반복 타입을 주간으로 변경
      fireEvent.change(screen.getByDisplayValue('매일'), { target: { value: 'weekly' } });

      expect(mockOnRepeatTypeChange).toHaveBeenCalledWith('weekly');
      expect(mockOnWeeklyOptionsChange).toHaveBeenCalledWith({ daysOfWeek: [] });
    });

    it('주간에서 다른 타입으로 변경 시 weeklyOptions 제거', () => {
      const mockOnWeeklyOptionsChange = jest.fn();
      const mockOnRepeatTypeChange = jest.fn();

      render(
        <RepeatSection
          {...defaultProps}
          repeatType="weekly"
          onRepeatTypeChange={mockOnRepeatTypeChange}
          weeklyOptions={{ daysOfWeek: [1, 3, 5] }}
          onWeeklyOptionsChange={mockOnWeeklyOptionsChange}
        />
      );

      // 반복 타입을 일간으로 변경
      fireEvent.change(screen.getByDisplayValue('매주'), { target: { value: 'daily' } });

      expect(mockOnRepeatTypeChange).toHaveBeenCalledWith('daily');
      expect(mockOnWeeklyOptionsChange).toHaveBeenCalledWith(undefined);
    });

    it('요일 선택 변경 시 상위로 전파', () => {
      const mockOnWeeklyOptionsChange = jest.fn();

      render(
        <RepeatSection
          {...defaultProps}
          weeklyOptions={{ daysOfWeek: [] }}
          onWeeklyOptionsChange={mockOnWeeklyOptionsChange}
        />
      );

      // 월요일 체크박스 클릭
      fireEvent.click(screen.getByLabelText('월요일 선택'));

      expect(mockOnWeeklyOptionsChange).toHaveBeenCalledWith([1]);
    });
  });

  describe('하위 호환성', () => {
    it('weeklyOptions props 없이도 정상 동작', () => {
      expect(() => {
        render(<RepeatSection {...defaultProps} />);
      }).not.toThrow();

      // 기본 반복 설정 UI는 정상 표시되어야 함
      expect(screen.getByText('반복 유형')).toBeInTheDocument();
    });

    it('기존 사용법 그대로 동작', () => {
      const { rerender } = render(<RepeatSection {...defaultProps} />);

      // props 변경해도 오류 없이 동작
      rerender(<RepeatSection {...defaultProps} repeatType="monthly" />);
      expect(screen.getByDisplayValue('매월')).toBeInTheDocument();
    });
  });
});
```

#### 2. 상태 전파 테스트

```typescript
describe('상태 전파', () => {
  it('복잡한 상태 변경 시나리오', () => {
    const mockCallbacks = {
      onRepeatTypeChange: jest.fn(),
      onWeeklyOptionsChange: jest.fn(),
    };

    const { rerender } = render(
      <RepeatSection {...defaultProps} repeatType="daily" {...mockCallbacks} />
    );

    // 1. daily → weekly 변경
    fireEvent.change(screen.getByDisplayValue('매일'), { target: { value: 'weekly' } });
    expect(mockCallbacks.onWeeklyOptionsChange).toHaveBeenCalledWith({ daysOfWeek: [] });

    // 2. 요일 선택
    rerender(
      <RepeatSection
        {...defaultProps}
        repeatType="weekly"
        weeklyOptions={{ daysOfWeek: [] }}
        {...mockCallbacks}
      />
    );

    fireEvent.click(screen.getByLabelText('월요일 선택'));
    expect(mockCallbacks.onWeeklyOptionsChange).toHaveBeenCalledWith([1]);

    // 3. weekly → monthly 변경
    fireEvent.change(screen.getByDisplayValue('매주'), { target: { value: 'monthly' } });
    expect(mockCallbacks.onWeeklyOptionsChange).toHaveBeenCalledWith(undefined);
  });
});
```

### 통합 테스트 케이스

#### 1. EventForm 통합 테스트

```typescript
describe('EventForm 통합', () => {
  it('EventForm에서 RepeatSection 사용 시 전체 플로우 동작', () => {
    // EventForm 컴포넌트에서 RepeatSection 사용
    // 실제 사용 시나리오와 동일한 테스트

    render(<EventForm />);

    // 1. 반복 일정 활성화
    fireEvent.click(screen.getByLabelText('반복 일정'));

    // 2. 주간 반복 선택
    fireEvent.change(screen.getByLabelText('반복 유형'), { target: { value: 'weekly' } });

    // 3. 요일 선택
    fireEvent.click(screen.getByLabelText('월요일 선택'));
    fireEvent.click(screen.getByLabelText('수요일 선택'));

    // 4. 폼 제출
    fireEvent.click(screen.getByText('일정 추가'));

    // RepeatInfo에 weeklyOptions가 포함되었는지 확인
    // (실제 구현에서는 onSubmit 핸들러 테스트)
  });
});
```

#### 2. 스타일 통합 테스트

```typescript
describe('스타일 통합', () => {
  it('WeeklyDaysSelector가 RepeatSection 스타일과 일치', () => {
    render(
      <RepeatSection
        {...defaultProps}
        weeklyOptions={{ daysOfWeek: [] }}
        onWeeklyOptionsChange={jest.fn()}
      />
    );

    const repeatSection = screen.getByText('반복 유형').closest('[class*="MuiStack"]');
    const weeklySelector = screen.getByText('반복 요일').closest('[class*="MuiFormControl"]');

    // 간격과 여백이 일관성 있는지 확인
    expect(repeatSection).toHaveStyle('gap: 16px'); // Material-UI spacing(2)
    expect(weeklySelector).toBeInTheDocument();
  });
});
```

## 완료 정의 (Definition of Done)

### 기능 완료 기준

- [ ] RepeatSection Props 인터페이스 확장
- [ ] 조건부 WeeklyDaysSelector 렌더링 구현
- [ ] weeklyOptions 상태 관리 로직 구현
- [ ] 반복 타입 변경 시 상태 초기화 구현

### 품질 기준

- [ ] 모든 단위 테스트 통과 (95% 이상 커버리지)
- [ ] 통합 테스트 통과
- [ ] 하위 호환성 검증 완료
- [ ] 기존 기능 회귀 테스트 통과

### 디자인 기준

- [ ] 기존 RepeatSection 스타일 일관성 유지
- [ ] WeeklyDaysSelector 자연스러운 통합
- [ ] 반응형 디자인에서 올바른 배치
- [ ] Material-UI 디자인 시스템 준수

### 통합 기준

- [ ] EventForm에서 정상 동작
- [ ] 기존 사용 코드 변경 없이 동작
- [ ] 새로운 기능과 기존 기능 충돌 없음

### 문서화 기준

- [ ] 새로운 Props 문서화
- [ ] 사용 예시 코드 업데이트
- [ ] 마이그레이션 가이드 작성 (선택사항)

## 위험 요소 및 완화 전략

### 위험 요소

1. **기존 코드 호환성**: 새로운 props로 인한 기존 사용법 영향
2. **복잡한 상태 관리**: weeklyOptions와 repeatType 간 동기화
3. **성능 영향**: 조건부 렌더링과 상태 변경으로 인한 리렌더링

### 완화 전략

1. **옵셔널 props**: 모든 새로운 props를 옵셔널로 설계
2. **명확한 상태 흐름**: 단방향 데이터 플로우 유지
3. **최적화**: React.memo와 useCallback 적절히 활용

## 다음 스토리와의 연계

이 스토리 완료 후:

- **스토리 1.5**: 전체 통합 테스트에서 RepeatSection 포함
- **향후 확장**: 월간 반복 옵션 등 추가 기능 지원 가능

## 리뷰 체크리스트

### 아키텍처 일관성

- [ ] 기존 컴포넌트 패턴 준수
- [ ] Props drilling 최소화
- [ ] 단일 책임 원칙 유지

### 사용성

- [ ] 직관적인 사용자 인터페이스
- [ ] 명확한 상태 피드백
- [ ] 오류 상황 적절한 처리

### 확장성

- [ ] 향후 추가 반복 옵션 지원 가능
- [ ] 재사용 가능한 구조
- [ ] 테스트 가능한 설계

---

이 스토리는 주간 반복 요일 선택 기능을 기존 RepeatSection에 매끄럽게 통합하여, 사용자에게 일관되고 직관적인 경험을 제공합니다.

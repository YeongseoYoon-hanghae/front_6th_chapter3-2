# 스토리 1.5: 통합 테스트 및 기존 기능 검증

## 스토리 개요

**As a** QA 엔지니어  
**I want** 새로운 주간 요일 선택 기능이 기존 반복 일정 기능과 완벽히 호환된다  
**So that** 기존 사용자의 일정이 영향받지 않고 새로운 기능을 안전하게 제공할 수 있다

## 비즈니스 컨텍스트

### 현재 상태

- 스토리 1.1~1.4가 개별적으로 구현 완료
- 각 컴포넌트별 단위 테스트 존재
- 전체 시스템 통합 검증 필요

### 목표 상태

- 새로운 기능과 기존 기능 간 완전한 호환성 검증
- 전체 사용자 플로우 E2E 테스트 완료
- 성능 및 안정성 회귀 테스트 통과
- 프로덕션 배포 준비 완료

### 검증 범위

```
1. 기존 반복 일정 기능 (weeklyOptions 없음) 정상 동작
2. 새로운 주간 요일 선택 기능 모든 시나리오 동작
3. 두 기능 간 상호작용 시 충돌 없음
4. 성능 요구사항 (20% 이하 성능 저하) 충족
5. 접근성 및 사용성 기준 만족
```

## 수락 기준

### AC1: 기존 반복 일정 완전 호환성

**Given** 기존 방식으로 생성된 반복 일정이 있을 때  
**When** 새로운 시스템에서 해당 일정을 조회/수정할 때  
**Then** 아무런 변경 없이 정상 동작해야 한다

**검증 시나리오:**

```typescript
// 기존 데이터 구조 (weeklyOptions 없음)
const existingEvents: Event[] = [
  {
    id: '1',
    title: '기존 주간 회의',
    date: '2024-01-01',
    repeat: { type: 'weekly', interval: 1, endDate: '2024-12-31' },
    // weeklyOptions 없음
  },
];
```

**검증 기준:**

- [ ] 기존 일정 목록에서 정상 표시
- [ ] 기존 일정 수정 시 weeklyOptions 추가되지 않음
- [ ] 기존 반복 날짜 계산 정확성 유지
- [ ] 기존 UI 플로우 변경 없음

### AC2: 새로운 기능 전체 시나리오 검증

**Given** 사용자가 새로운 주간 요일 선택 기능을 사용할 때  
**When** 모든 사용 시나리오를 수행할 때  
**Then** 예상대로 정확히 동작해야 한다

**시나리오 목록:**

1. **기본 요일 선택**: 월, 수, 금 선택하여 일정 생성
2. **단일 요일**: 토요일만 선택하여 일정 생성
3. **모든 요일**: 7개 요일 모두 선택하여 일정 생성
4. **요일 변경**: 기존 일정의 요일 선택 수정
5. **반복 타입 변경**: 주간 → 일간 → 주간 전환
6. **유효성 검증**: 요일 미선택 시 오류 처리

**검증 기준:**

- [ ] 모든 시나리오에서 예상 결과 생성
- [ ] 날짜 계산 정확성 100%
- [ ] UI 상태 변경 적절함
- [ ] 오류 상황 적절한 처리

### AC3: E2E 사용자 플로우 검증

**Given** 실제 사용자가 애플리케이션을 사용할 때  
**When** 처음부터 끝까지 전체 플로우를 수행할 때  
**Then** 자연스럽고 일관된 사용자 경험이 제공되어야 한다

**E2E 플로우:**

```
1. 애플리케이션 접속
2. "일정 추가" 버튼 클릭
3. 기본 정보 입력 (제목, 날짜, 시간 등)
4. "반복 일정" 체크박스 활성화
5. "매주" 반복 타입 선택
6. 원하는 요일들 선택 (예: 월, 수, 금)
7. 반복 간격 및 종료일 설정
8. "일정 추가" 버튼 클릭
9. 캘린더에서 생성된 반복 일정 확인
10. 일정 수정/삭제 테스트
```

**검증 기준:**

- [ ] 전체 플로우가 5분 이내 완료 가능
- [ ] 각 단계에서 명확한 피드백 제공
- [ ] 오류 발생 시 적절한 안내 메시지
- [ ] 다양한 브라우저에서 동일한 동작

### AC4: 성능 요구사항 충족

**Given** 새로운 기능이 추가된 시스템에서  
**When** 기존 성능 기준 테스트를 수행할 때  
**Then** NFR1 기준(20% 이하 성능 저하)을 충족해야 한다

**성능 측정 항목:**

- 일정 생성 시간
- 반복 날짜 계산 시간
- 캘린더 렌더링 시간
- 메모리 사용량

**검증 기준:**

- [ ] 일정 생성: 기존 대비 20% 이하 증가
- [ ] 날짜 계산: 기존 대비 20% 이하 증가
- [ ] UI 렌더링: 기존 대비 20% 이하 증가
- [ ] 메모리 누수 없음

### AC5: 데이터 무결성 및 호환성

**Given** 기존 데이터와 새로운 데이터가 혼재할 때  
**When** 시스템에서 데이터를 처리할 때  
**Then** 모든 데이터가 올바르게 처리되어야 한다

**검증 기준:**

- [ ] 기존 RepeatInfo 구조 데이터 정상 처리
- [ ] 새로운 weeklyOptions 포함 데이터 정상 처리
- [ ] 데이터 직렬화/역직렬화 정확성
- [ ] 마이그레이션 없이 자동 호환

## 통합 검증 기준

### IV1: 기존 사용자 데이터 마이그레이션 없음

**검증 시나리오:**

- 프로덕션 환경의 기존 사용자 데이터 샘플로 테스트
- weeklyOptions 없는 기존 일정들이 정상 동작함을 확인
- 기존 일정 수정 시 weeklyOptions 자동 추가되지 않음

### IV2: 기능 간 상호작용 충돌 없음

**검증 시나리오:**

- 기존 기능과 새로운 기능을 번갈아 사용
- 일정 타입 변경 시 데이터 일관성 유지
- 동시 사용자 시나리오에서 데이터 충돌 없음

### IV3: 전체 애플리케이션 안정성

**검증 기준:**

- 장시간 사용 시 메모리 누수 없음
- 대량 데이터 처리 시 성능 저하 최소
- 예외 상황에서 시스템 크래시 없음

## 기술적 구현 요구사항

### 테스트 파일 구조

```
src/__tests__/
├── integration/
│   ├── weekly-repeat-selection.integration.test.tsx
│   ├── backward-compatibility.integration.test.tsx
│   └── performance.integration.test.ts
├── e2e/
│   ├── weekly-repeat-flow.e2e.test.ts
│   └── regression.e2e.test.ts
└── utils/
    ├── test-data-generator.ts
    └── performance-helpers.ts
```

### 통합 테스트 구현

#### 1. 기존 기능 호환성 테스트

```typescript
// backward-compatibility.integration.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { EventForm } from '../../components/EventForm';
import { generateRepeatEvents, generateRepeatEventsWithOptions } from '../../utils/recurringUtils';
import { Event, EventForm as EventFormType } from '../../types';

describe('기존 기능 호환성 통합 테스트', () => {
  describe('기존 데이터 구조 처리', () => {
    it('weeklyOptions 없는 기존 일정이 정상 동작함', () => {
      const existingEvent: Event = {
        id: '1',
        title: '기존 주간 회의',
        date: '2024-01-01',
        startTime: '09:00',
        endTime: '10:00',
        description: '',
        location: '회의실 A',
        category: '업무',
        repeat: {
          type: 'weekly',
          interval: 1,
          endDate: '2024-01-31',
          // weeklyOptions 없음
        },
        notificationTime: 10,
      };

      // 기존 함수로 반복 일정 생성
      const oldResult = generateRepeatEvents(existingEvent);

      // 새로운 함수로 동일한 결과 생성되는지 확인
      const newResult = generateRepeatEventsWithOptions(existingEvent);

      expect(newResult).toEqual(oldResult);
      expect(newResult.length).toBe(5); // 매주 월요일 5번
    });

    it('기존 일정 수정 시 weeklyOptions 자동 추가되지 않음', async () => {
      const existingEvent: Event = {
        id: '1',
        title: '기존 일정',
        date: '2024-01-01',
        startTime: '09:00',
        endTime: '10:00',
        description: '',
        location: '',
        category: '',
        repeat: { type: 'weekly', interval: 1 },
        notificationTime: 10,
      };

      const mockOnSubmit = jest.fn();

      render(<EventForm initialData={existingEvent} onSubmit={mockOnSubmit} />);

      // 제목만 수정
      fireEvent.change(screen.getByLabelText('제목'), {
        target: { value: '수정된 제목' },
      });

      fireEvent.click(screen.getByText('일정 수정'));

      await waitFor(() => {
        expect(mockOnSubmit).toHaveBeenCalled();
        const submittedData = mockOnSubmit.mock.calls[0][0];
        expect(submittedData.repeat.weeklyOptions).toBeUndefined();
      });
    });
  });

  describe('기존 UI 플로우 유지', () => {
    it('weeklyOptions 지원 없는 RepeatSection 사용법', () => {
      const mockProps = {
        isRepeating: true,
        onIsRepeatingChange: jest.fn(),
        repeatType: 'weekly' as const,
        onRepeatTypeChange: jest.fn(),
        repeatInterval: 1,
        onRepeatIntervalChange: jest.fn(),
        repeatEndDate: '',
        onRepeatEndDateChange: jest.fn(),
        // weeklyOptions 관련 props 없음
      };

      expect(() => {
        render(<RepeatSection {...mockProps} />);
      }).not.toThrow();

      // 기본 UI 요소들 정상 렌더링
      expect(screen.getByText('반복 일정')).toBeInTheDocument();
      expect(screen.getByText('반복 유형')).toBeInTheDocument();

      // WeeklyDaysSelector는 표시되지 않아야 함
      expect(screen.queryByText('반복 요일')).not.toBeInTheDocument();
    });
  });
});
```

#### 2. 새로운 기능 전체 시나리오 테스트

```typescript
// weekly-repeat-selection.integration.test.tsx
describe('주간 요일 선택 기능 통합 테스트', () => {
  describe('전체 시나리오 검증', () => {
    it('시나리오 1: 평일 운동 일정 생성', async () => {
      const mockOnSubmit = jest.fn();
      render(<EventForm onSubmit={mockOnSubmit} />);

      // 1. 기본 정보 입력
      fireEvent.change(screen.getByLabelText('제목'), {
        target: { value: '평일 운동' },
      });
      fireEvent.change(screen.getByLabelText('날짜'), {
        target: { value: '2024-01-01' },
      });

      // 2. 반복 일정 활성화
      fireEvent.click(screen.getByLabelText('반복 일정'));

      // 3. 주간 반복 선택
      fireEvent.change(screen.getByLabelText('반복 유형'), {
        target: { value: 'weekly' },
      });

      // 4. 평일만 선택 (월~금)
      ['월요일', '화요일', '수요일', '목요일', '금요일'].forEach((day) => {
        fireEvent.click(screen.getByLabelText(`${day} 선택`));
      });

      // 5. 반복 설정
      fireEvent.change(screen.getByLabelText('반복 간격'), {
        target: { value: '1' },
      });
      fireEvent.change(screen.getByLabelText('반복 종료일'), {
        target: { value: '2024-01-31' },
      });

      // 6. 일정 추가
      fireEvent.click(screen.getByText('일정 추가'));

      // 7. 결과 검증
      await waitFor(() => {
        expect(mockOnSubmit).toHaveBeenCalled();
        const eventData = mockOnSubmit.mock.calls[0][0];

        expect(eventData.title).toBe('평일 운동');
        expect(eventData.repeat.type).toBe('weekly');
        expect(eventData.repeat.weeklyOptions.daysOfWeek).toEqual([1, 2, 3, 4, 5]);
      });

      // 8. 생성된 반복 일정 수 확인
      const generatedEvents = generateRepeatEventsWithOptions(mockOnSubmit.mock.calls[0][0]);
      const expectedDays = 23; // 2024년 1월 평일 수
      expect(generatedEvents.length).toBe(expectedDays);
    });

    it('시나리오 2: 주말 가족 시간 일정', async () => {
      const mockOnSubmit = jest.fn();
      render(<EventForm onSubmit={mockOnSubmit} />);

      // 주말(토, 일)만 선택하는 시나리오
      fireEvent.change(screen.getByLabelText('제목'), {
        target: { value: '가족 시간' },
      });

      fireEvent.click(screen.getByLabelText('반복 일정'));
      fireEvent.change(screen.getByLabelText('반복 유형'), {
        target: { value: 'weekly' },
      });

      fireEvent.click(screen.getByLabelText('토요일 선택'));
      fireEvent.click(screen.getByLabelText('일요일 선택'));

      fireEvent.click(screen.getByText('일정 추가'));

      await waitFor(() => {
        const eventData = mockOnSubmit.mock.calls[0][0];
        expect(eventData.repeat.weeklyOptions.daysOfWeek).toEqual([0, 6]);
      });
    });
  });

  describe('유효성 검증 시나리오', () => {
    it('요일 미선택 시 오류 처리', async () => {
      render(<EventForm />);

      fireEvent.click(screen.getByLabelText('반복 일정'));
      fireEvent.change(screen.getByLabelText('반복 유형'), {
        target: { value: 'weekly' },
      });

      // 요일 선택하지 않고 제출 시도
      fireEvent.click(screen.getByText('일정 추가'));

      // 오류 메시지 표시 확인
      await waitFor(() => {
        expect(screen.getByText('최소 1개 요일을 선택해주세요')).toBeInTheDocument();
      });
    });

    it('반복 타입 변경 시 상태 초기화', () => {
      render(<EventForm />);

      fireEvent.click(screen.getByLabelText('반복 일정'));
      fireEvent.change(screen.getByLabelText('반복 유형'), {
        target: { value: 'weekly' },
      });

      // 요일 선택
      fireEvent.click(screen.getByLabelText('월요일 선택'));
      expect(screen.getByLabelText('월요일 선택')).toBeChecked();

      // 다른 반복 타입으로 변경
      fireEvent.change(screen.getByLabelText('반복 유형'), {
        target: { value: 'daily' },
      });

      // WeeklyDaysSelector 숨겨짐
      expect(screen.queryByText('반복 요일')).not.toBeInTheDocument();

      // 다시 주간으로 변경
      fireEvent.change(screen.getByLabelText('반복 유형'), {
        target: { value: 'weekly' },
      });

      // 이전 선택 상태 초기화됨
      expect(screen.getByLabelText('월요일 선택')).not.toBeChecked();
    });
  });
});
```

#### 3. 성능 테스트

```typescript
// performance.integration.test.ts
describe('성능 요구사항 검증', () => {
  describe('반복 날짜 계산 성능', () => {
    it('기존 함수 대비 20% 이하 성능 저하', () => {
      const testData = {
        startDate: '2024-01-01',
        endDate: '2024-12-31',
        repeatType: 'weekly' as const,
        interval: 1,
      };

      const iterations = 1000;

      // 기존 함수 성능 측정
      const start1 = performance.now();
      for (let i = 0; i < iterations; i++) {
        calculateRecurringDates(
          testData.startDate,
          testData.endDate,
          testData.repeatType,
          testData.interval
        );
      }
      const time1 = performance.now() - start1;

      // 새로운 함수 성능 측정 (weeklyOptions 없이)
      const start2 = performance.now();
      for (let i = 0; i < iterations; i++) {
        calculateRecurringDatesWithOptions(
          testData.startDate,
          testData.endDate,
          testData.repeatType,
          testData.interval
        );
      }
      const time2 = performance.now() - start2;

      // 20% 이하 성능 저하 검증
      expect(time2).toBeLessThanOrEqual(time1 * 1.2);
    });

    it('주간 요일 선택 계산 성능', () => {
      const weeklyOptions = { daysOfWeek: [1, 3, 5] }; // 월, 수, 금

      const start = performance.now();

      // 1년간 반복 계산
      calculateWeeklyWithSpecificDays('2024-01-01', '2024-12-31', 1, weeklyOptions);

      const time = performance.now() - start;

      // 100ms 이하로 완료되어야 함
      expect(time).toBeLessThan(100);
    });
  });

  describe('UI 렌더링 성능', () => {
    it('WeeklyDaysSelector 렌더링 성능', () => {
      const mockProps = {
        selectedDays: [1, 3, 5],
        onSelectionChange: jest.fn(),
      };

      const start = performance.now();

      render(<WeeklyDaysSelector {...mockProps} />);

      const time = performance.now() - start;

      // 50ms 이하로 렌더링되어야 함
      expect(time).toBeLessThan(50);
    });
  });

  describe('메모리 사용량', () => {
    it('메모리 누수 없음', () => {
      const initialMemory = (performance as any).memory?.usedJSHeapSize || 0;

      // 컴포넌트를 여러 번 마운트/언마운트
      for (let i = 0; i < 100; i++) {
        const { unmount } = render(
          <WeeklyDaysSelector selectedDays={[i % 7]} onSelectionChange={jest.fn()} />
        );
        unmount();
      }

      // 가비지 컬렉션 강제 실행 (테스트 환경에서만)
      if (global.gc) {
        global.gc();
      }

      const finalMemory = (performance as any).memory?.usedJSHeapSize || 0;

      // 메모리 증가량이 1MB 이하여야 함
      expect(finalMemory - initialMemory).toBeLessThan(1024 * 1024);
    });
  });
});
```

### E2E 테스트 구현

#### Playwright E2E 테스트

```typescript
// tests/e2e/weekly-repeat-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('주간 반복 요일 선택 E2E', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('전체 사용자 플로우: 평일 운동 일정 생성', async ({ page }) => {
    // 1. 일정 추가 시작
    await page.click('button:has-text("일정 추가")');

    // 2. 기본 정보 입력
    await page.fill('input[aria-label="제목"]', '평일 운동');
    await page.fill('input[type="date"]', '2024-01-01');
    await page.fill('input[aria-label="시작 시간"]', '07:00');
    await page.fill('input[aria-label="종료 시간"]', '08:00');

    // 3. 반복 일정 활성화
    await page.check('input[aria-label="반복 일정"]');

    // 4. 주간 반복 선택
    await page.selectOption('select[aria-label="반복 유형"]', 'weekly');

    // 5. 평일 선택 (월~금)
    const weekdays = ['월요일', '화요일', '수요일', '목요일', '금요일'];
    for (const day of weekdays) {
      await page.check(`input[aria-label="${day} 선택"]`);
    }

    // 6. 반복 설정
    await page.fill('input[aria-label="반복 간격"]', '1');
    await page.fill('input[aria-label="반복 종료일"]', '2024-01-31');

    // 7. 일정 저장
    await page.click('button:has-text("일정 추가")');

    // 8. 성공 메시지 확인
    await expect(page.locator('text=일정이 추가되었습니다')).toBeVisible();

    // 9. 캘린더에서 생성된 일정 확인
    await expect(page.locator('text=평일 운동')).toBeVisible();

    // 10. 주말에는 일정이 없는지 확인
    await page.click('button:has-text("월간 보기")');

    // 토요일, 일요일에 해당 일정이 없는지 확인
    const saturdayEvents = page.locator('[data-testid="calendar-day-6"] >> text=평일 운동');
    const sundayEvents = page.locator('[data-testid="calendar-day-0"] >> text=평일 운동');

    await expect(saturdayEvents).toHaveCount(0);
    await expect(sundayEvents).toHaveCount(0);
  });

  test('일정 수정: 요일 변경', async ({ page }) => {
    // 기존 일정 클릭하여 수정 모드 진입
    await page.click('text=평일 운동');
    await page.click('button:has-text("수정")');

    // 금요일 선택 해제
    await page.uncheck('input[aria-label="금요일 선택"]');

    // 토요일 추가 선택
    await page.check('input[aria-label="토요일 선택"]');

    // 저장
    await page.click('button:has-text("일정 수정")');

    // 변경사항 반영 확인
    await expect(page.locator('text=일정이 수정되었습니다')).toBeVisible();
  });

  test('접근성: 키보드 네비게이션', async ({ page }) => {
    await page.click('button:has-text("일정 추가")');
    await page.check('input[aria-label="반복 일정"]');
    await page.selectOption('select[aria-label="반복 유형"]', 'weekly');

    // 첫 번째 요일 체크박스에 포커스
    await page.focus('input[aria-label="일요일 선택"]');

    // Tab으로 다음 체크박스들로 이동
    for (let i = 0; i < 6; i++) {
      await page.keyboard.press('Tab');
    }

    // 마지막 체크박스(토요일)에 포커스되었는지 확인
    await expect(page.locator('input[aria-label="토요일 선택"]')).toBeFocused();

    // Space로 체크박스 선택
    await page.keyboard.press('Space');
    await expect(page.locator('input[aria-label="토요일 선택"]')).toBeChecked();
  });

  test('반응형 디자인: 모바일 환경', async ({ page }) => {
    // 모바일 뷰포트로 설정
    await page.setViewportSize({ width: 375, height: 667 });

    await page.click('button:has-text("일정 추가")');
    await page.check('input[aria-label="반복 일정"]');
    await page.selectOption('select[aria-label="반복 유형"]', 'weekly');

    // 모바일에서도 모든 요일 체크박스가 보이고 클릭 가능한지 확인
    const weekdays = ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'];

    for (const day of weekdays) {
      const checkbox = page.locator(`input[aria-label="${day} 선택"]`);
      await expect(checkbox).toBeVisible();
      await expect(checkbox).toBeEnabled();
    }
  });
});
```

### 성능 모니터링 도구

#### 성능 측정 헬퍼

```typescript
// src/__tests__/utils/performance-helpers.ts
export class PerformanceMonitor {
  private measurements: Map<string, number[]> = new Map();

  startMeasurement(name: string): () => number {
    const start = performance.now();
    return () => {
      const duration = performance.now() - start;
      this.recordMeasurement(name, duration);
      return duration;
    };
  }

  recordMeasurement(name: string, duration: number): void {
    if (!this.measurements.has(name)) {
      this.measurements.set(name, []);
    }
    this.measurements.get(name)!.push(duration);
  }

  getStatistics(name: string): {
    average: number;
    min: number;
    max: number;
    count: number;
  } | null {
    const measurements = this.measurements.get(name);
    if (!measurements || measurements.length === 0) {
      return null;
    }

    return {
      average: measurements.reduce((a, b) => a + b, 0) / measurements.length,
      min: Math.min(...measurements),
      max: Math.max(...measurements),
      count: measurements.length,
    };
  }

  assertPerformance(name: string, maxAverage: number, maxWorst: number): void {
    const stats = this.getStatistics(name);
    expect(stats).not.toBeNull();
    expect(stats!.average).toBeLessThan(maxAverage);
    expect(stats!.max).toBeLessThan(maxWorst);
  }

  reset(): void {
    this.measurements.clear();
  }
}

// 사용 예시
export const performanceMonitor = new PerformanceMonitor();

export function measureAsync<T>(name: string, fn: () => Promise<T>): Promise<T> {
  const endMeasurement = performanceMonitor.startMeasurement(name);
  return fn().finally(() => {
    endMeasurement();
  });
}

export function measureSync<T>(name: string, fn: () => T): T {
  const endMeasurement = performanceMonitor.startMeasurement(name);
  try {
    return fn();
  } finally {
    endMeasurement();
  }
}
```

## 완료 정의 (Definition of Done)

### 기능 완료 기준

- [ ] 모든 통합 테스트 작성 및 통과
- [ ] E2E 테스트 시나리오 완성 및 통과
- [ ] 성능 테스트 구현 및 기준 충족
- [ ] 회귀 테스트 완료

### 품질 기준

- [ ] 테스트 커버리지 95% 이상
- [ ] 모든 브라우저에서 E2E 테스트 통과
- [ ] 성능 요구사항 (20% 이하 성능 저하) 충족
- [ ] 메모리 누수 없음

### 호환성 기준

- [ ] 기존 데이터 100% 호환성
- [ ] 기존 API 사용법 변경 없음
- [ ] 기존 UI 플로우 영향 없음
- [ ] 마이그레이션 스크립트 불필요

### 사용성 기준

- [ ] 전체 사용자 플로우 5분 이내 완료
- [ ] 접근성 기준 (WCAG 2.1 AA) 충족
- [ ] 모바일 환경에서 정상 동작
- [ ] 키보드 네비게이션 완전 지원

### 배포 준비 기준

- [ ] CI/CD 파이프라인 통합
- [ ] 모니터링 대시보드 설정
- [ ] 롤백 계획 수립
- [ ] 배포 후 검증 체크리스트 작성

## 위험 요소 및 완화 전략

### 위험 요소

1. **성능 회귀**: 새로운 기능으로 인한 예상보다 큰 성능 저하
2. **데이터 호환성**: 예상치 못한 기존 데이터 형식 이슈
3. **브라우저 호환성**: 특정 브라우저에서의 동작 차이

### 완화 전략

1. **점진적 성능 최적화**: 병목 지점 식별 후 순차적 개선
2. **다양한 데이터 샘플 테스트**: 실제 프로덕션 데이터 패턴 반영
3. **크로스 브라우저 자동 테스트**: CI/CD에 브라우저 매트릭스 포함

## 다음 단계

이 스토리 완료 후:

- 프로덕션 환경 배포 준비
- 사용자 피드백 수집 계획
- 향후 기능 확장 로드맵 수립

## 리뷰 체크리스트

### 테스트 품질

- [ ] 모든 시나리오 커버
- [ ] 실제 사용 패턴 반영
- [ ] 성능 기준 명확히 정의

### 자동화 수준

- [ ] CI/CD 파이프라인 완전 통합
- [ ] 수동 테스트 최소화
- [ ] 실패 시 명확한 오류 메시지

### 문서화

- [ ] 테스트 실행 가이드
- [ ] 성능 벤치마크 문서
- [ ] 트러블슈팅 가이드

---

이 스토리는 주간 반복 요일 선택 기능의 품질과 안정성을 보장하며, 기존 시스템과의 완벽한 호환성을 검증하여 안전한 프로덕션 배포를 준비합니다.

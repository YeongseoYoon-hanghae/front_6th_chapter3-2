# Story 2.4: 반복 일정 단일 삭제

## Status

Draft

## Story

**As a** 캘린더 사용자,
**I want** 반복 일정 중 하나만 삭제할 수 있고,
**so that** 특정 날짜의 일정만 취소가 필요할 때 나머지는 유지할 수 있다.

## Acceptance Criteria

1. 반복 일정 중 선택한 인스턴스만 삭제된다
2. 기존 DELETE API를 활용한다
3. 나머지 반복 일정들은 영향 받지 않는다
4. 삭제 확인 다이얼로그가 표시된다
5. 삭제 완료 시 즉시 캘린더에서 제거된다

## Sub-Stories

- [2.4.1 삭제 확인 다이얼로그](./2.4.1-recurring-delete-dialog.md)
- [2.4.2 단일 인스턴스 식별 및 삭제 로직](./2.4.2-recurring-single-delete-logic.md)
- [2.4.3 DELETE API 연동](./2.4.3-recurring-single-delete-api.md)
- [2.4.4 그룹 무결성 및 캘린더 업데이트](./2.4.4-recurring-delete-group-integrity-and-refresh.md)

## Tasks / Subtasks

- [ ] **반복 일정 삭제 확인 다이얼로그 구현** (AC: 4)

  - [ ] 반복 일정 삭제 시 특별 확인 다이얼로그 표시
  - [ ] "이 일정만 삭제" vs "전체 반복 일정 삭제" 옵션 제공
  - [ ] 삭제될 일정 정보 명확히 표시
  - [ ] 사용자 선택에 따른 분기 처리

- [ ] **단일 인스턴스 삭제 로직 구현** (AC: 1,2)

  - [ ] 반복 일정 중 특정 인스턴스 식별
  - [ ] 기존 DELETE `/api/events/:id` 엔드포인트 활용
  - [ ] 삭제 요청 및 응답 처리
  - [ ] 에러 발생 시 적절한 처리

- [ ] **반복 그룹 무결성 보장** (AC: 3)

  - [ ] 같은 그룹의 다른 일정들 영향도 검증
  - [ ] 반복 그룹 참조 무결성 유지
  - [ ] 삭제 후 그룹 데이터 일관성 확인
  - [ ] 잘못된 참조 정리 로직

- [ ] **캘린더 뷰 즉시 업데이트** (AC: 5)
  - [ ] 삭제 후 캘린더 상태 즉시 업데이트
  - [ ] 삭제 완료 피드백 메시지 표시
  - [ ] UI 반응성 최적화
  - [ ] 삭제 취소 기능 검토 (선택사항)

## Dev Notes

### 기술적 구현 세부사항

**반복 삭제 확인 다이얼로그:**

```typescript
// src/components/RecurringDeleteDialog.tsx (새로 생성)
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Typography,
  Alert,
} from '@mui/material';
import { Delete, Warning } from '@mui/icons-material';

interface RecurringDeleteDialogProps {
  open: boolean;
  event: Event;
  onConfirm: (choice: 'single' | 'all' | 'cancel') => void;
}

export const RecurringDeleteDialog: React.FC<RecurringDeleteDialogProps> = ({
  open,
  event,
  onConfirm,
}) => {
  const repeatTypeText = {
    daily: '매일',
    weekly: '매주',
    monthly: '매월',
    yearly: '매년',
  }[event.repeat.type];

  const formatEventDate = (dateStr: string) => {
    return new Date(dateStr).toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      weekday: 'long',
    });
  };

  return (
    <Dialog open={open} maxWidth="sm" fullWidth>
      <DialogTitle sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
        <Warning color="warning" />
        반복 일정 삭제
      </DialogTitle>
      <DialogContent>
        <Alert severity="info" sx={{ mb: 2 }}>
          "{event.title}"는 {repeatTypeText} 반복되는 일정입니다.
        </Alert>

        <Typography variant="body1" gutterBottom>
          <strong>삭제할 일정:</strong> {formatEventDate(event.date)}
        </Typography>
        <Typography variant="body1" gutterBottom>
          <strong>시간:</strong> {event.startTime} - {event.endTime}
        </Typography>

        <Typography variant="body2" color="textSecondary" sx={{ mt: 2 }}>
          어떻게 삭제하시겠습니까?
        </Typography>
      </DialogContent>
      <DialogActions>
        <Button onClick={() => onConfirm('cancel')} color="secondary">
          취소
        </Button>
        <Button
          onClick={() => onConfirm('single')}
          variant="contained"
          color="error"
          startIcon={<Delete />}
        >
          이 일정만 삭제
        </Button>
        <Button
          onClick={() => onConfirm('all')}
          variant="outlined"
          color="error"
          disabled // Story 3.2에서 구현 예정
        >
          전체 반복 일정 삭제 (추후 지원)
        </Button>
      </DialogActions>
    </Dialog>
  );
};
```

**단일 삭제 처리 로직:**

```typescript
// useEventOperations 확장
const handleDeleteRecurringEvent = async (event: Event) => {
  // 반복 일정인지 확인
  if (event.repeat.id && event.repeat.type !== 'none') {
    return new Promise<void>((resolve, reject) => {
      setDeleteDialogState({
        open: true,
        event,
        onConfirm: async (choice: 'single' | 'all' | 'cancel') => {
          setDeleteDialogState({ open: false, event: null, onConfirm: null });

          if (choice === 'cancel') {
            resolve();
            return;
          }

          try {
            if (choice === 'single') {
              await deleteSingleInstance(event);
              showSuccessMessage(`"${event.title}" 일정이 삭제되었습니다.`);
            } else if (choice === 'all') {
              // Story 3.2에서 구현 예정
              await deleteAllInstances(event);
            }
            resolve();
          } catch (error) {
            console.error('Delete error:', error);
            showErrorMessage('일정 삭제 중 오류가 발생했습니다.');
            reject(error);
          }
        },
      });
    });
  } else {
    // 일반 단일 일정 삭제
    return deleteSingleEvent(event);
  }
};

const deleteSingleInstance = async (event: Event): Promise<void> => {
  try {
    const response = await fetch(`/api/events/${event.id}`, {
      method: 'DELETE',
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // 캘린더 상태에서 해당 일정 제거
    setEvents((prevEvents) => prevEvents.filter((e) => e.id !== event.id));

    // 반복 그룹 무결성 검증
    validateRecurringGroupAfterDelete(event.repeat.id, events);
  } catch (error) {
    console.error('단일 일정 삭제 실패:', error);
    throw error;
  }
};
```

## Change Log

| 날짜       | 변경 사항           | 작성자 |
| ---------- | ------------------- | ------ |
| 2024-12-19 | Story 2.4 초기 생성 | PO     |

## Dependencies

**전제 조건:**

- Story 2.1 (반복 일정 생성) 완료
- Story 2.3 (반복 일정 단일 수정) 완료 (유사한 패턴 활용)
- 기존 DELETE `/api/events/:id` API 정상 동작

# 스토리 1.1: 타입 정의 및 데이터 모델 확장

## 스토리 개요

**As a** 개발자  
**I want** RepeatInfo 타입에 weeklyOptions 필드를 추가하고 관련 타입을 정의할 수 있다  
**So that** 주간 반복 요일 선택 기능의 기반 데이터 구조를 구축할 수 있다

## 비즈니스 컨텍스트

### 현재 상태

- RepeatInfo는 현재 type, interval, endDate, id 필드만 가지고 있음
- 주간 반복은 단순히 7일 간격으로만 계산됨
- 특정 요일 선택 기능이 없어 유연성 부족

### 목표 상태

- WeeklyOptions 타입을 통해 특정 요일 선택 지원
- RepeatInfo에 weeklyOptions 옵셔널 필드 추가
- 기존 코드와의 완전한 하위 호환성 유지

## 수락 기준

### AC1: WeeklyOptions 인터페이스 정의

```typescript
interface WeeklyOptions {
  daysOfWeek: number[]; // 0(일)~6(토) 배열
}
```

**Given** 주간 반복 요일 선택 기능 구현 시  
**When** 선택된 요일들을 저장해야 할 때  
**Then** WeeklyOptions 인터페이스가 daysOfWeek 숫자 배열을 포함해야 한다

**검증 기준:**

- [ ] daysOfWeek는 number[] 타입으로 정의됨
- [ ] 0(일요일)부터 6(토요일)까지의 값을 지원함
- [ ] 빈 배열, 단일 요일, 복수 요일 모든 경우를 지원함

### AC2: RepeatInfo 타입 확장

```typescript
interface RepeatInfo {
  type: RepeatType;
  interval: number;
  endDate?: string;
  id?: string;
  weeklyOptions?: WeeklyOptions; // 새로 추가
}
```

**Given** 기존 RepeatInfo 타입이 있을 때  
**When** 주간 반복 요일 선택 기능을 추가할 때  
**Then** weeklyOptions 옵셔널 필드가 추가되어야 한다

**검증 기준:**

- [ ] weeklyOptions는 옵셔널(?) 필드로 정의됨
- [ ] WeeklyOptions 타입을 참조함
- [ ] 기존 RepeatInfo 구조는 변경되지 않음

### AC3: 기존 코드 호환성 유지

**Given** 기존 RepeatInfo 객체들이 있을 때  
**When** 새로운 타입 정의가 적용될 때  
**Then** 기존 객체들이 수정 없이 정상 동작해야 한다

**검증 기준:**

- [ ] 기존 RepeatInfo 객체 생성 코드가 변경 없이 동작함
- [ ] weeklyOptions 없는 객체가 정상적으로 처리됨
- [ ] 타입 체킹에서 오류가 발생하지 않음

### AC4: TypeScript 컴파일 안정성

**Given** 새로운 타입이 정의될 때  
**When** TypeScript 컴파일을 실행할 때  
**Then** 컴파일 오류가 발생하지 않아야 한다

**검증 기준:**

- [ ] `npm run type-check` 명령이 성공함
- [ ] 기존 파일들에서 타입 오류가 없음
- [ ] 새로운 타입 정의가 올바르게 export됨

## 통합 검증 기준

### IV1: 기존 반복 일정 기능 호환성

**검증 시나리오:**

```typescript
// 기존 방식 - 변경 없이 동작해야 함
const existingRepeat: RepeatInfo = {
  type: 'weekly',
  interval: 1,
  endDate: '2024-12-31',
};
```

### IV2: 새로운 타입과 기존 코드 무충돌

**검증 시나리오:**

- RepeatSection 컴포넌트에서 RepeatInfo 사용 시 오류 없음
- EventForm 타입에서 repeat 필드 정상 동작
- 기존 유틸리티 함수들 정상 동작

### IV3: 성능 영향 없음

**검증 기준:**

- 타입 정의 추가로 인한 런타임 성능 변화 없음
- 메모리 사용량 변화 없음
- 컴파일 시간 유의미한 증가 없음

## 기술적 구현 요구사항

### 구현 파일

- **주 파일**: `src/types.ts`
- **테스트 파일**: `src/__tests__/unit/types.test.ts`

### 타입 정의 상세

```typescript
/**
 * 주간 반복 시 선택할 수 있는 요일 옵션
 * @interface WeeklyOptions
 */
export interface WeeklyOptions {
  /**
   * 선택된 요일 배열
   * 0: 일요일, 1: 월요일, ..., 6: 토요일
   * 예: [1, 3, 5] => 월, 수, 금요일
   */
  daysOfWeek: number[];
}

/**
 * 반복 일정 정보
 * @interface RepeatInfo
 */
export interface RepeatInfo {
  type: RepeatType;
  interval: number;
  endDate?: string;
  id?: string;
  /**
   * 주간 반복 시 특정 요일 선택 옵션
   * type이 'weekly'일 때만 사용됨
   */
  weeklyOptions?: WeeklyOptions;
}
```

### 타입 가드 함수 (선택사항)

```typescript
/**
 * WeeklyOptions가 있는 RepeatInfo인지 확인
 */
export function hasWeeklyOptions(
  repeat: RepeatInfo
): repeat is RepeatInfo & { weeklyOptions: WeeklyOptions } {
  return repeat.type === 'weekly' && repeat.weeklyOptions !== undefined;
}

/**
 * 유효한 요일 배열인지 검증
 */
export function isValidDaysOfWeek(days: number[]): boolean {
  return (
    days.length > 0 &&
    days.every((day) => day >= 0 && day <= 6) &&
    new Set(days).size === days.length
  ); // 중복 제거
}
```

## 테스트 전략

### 단위 테스트 케이스

#### 1. WeeklyOptions 타입 테스트

```typescript
describe('WeeklyOptions', () => {
  it('should accept valid days of week array', () => {
    const options: WeeklyOptions = { daysOfWeek: [1, 3, 5] };
    expect(options.daysOfWeek).toEqual([1, 3, 5]);
  });

  it('should accept empty array', () => {
    const options: WeeklyOptions = { daysOfWeek: [] };
    expect(options.daysOfWeek).toEqual([]);
  });

  it('should accept all days', () => {
    const options: WeeklyOptions = { daysOfWeek: [0, 1, 2, 3, 4, 5, 6] };
    expect(options.daysOfWeek).toHaveLength(7);
  });
});
```

#### 2. RepeatInfo 확장 테스트

```typescript
describe('RepeatInfo with weeklyOptions', () => {
  it('should work without weeklyOptions (backward compatibility)', () => {
    const repeat: RepeatInfo = {
      type: 'weekly',
      interval: 1,
    };
    expect(repeat.weeklyOptions).toBeUndefined();
  });

  it('should accept weeklyOptions when provided', () => {
    const repeat: RepeatInfo = {
      type: 'weekly',
      interval: 1,
      weeklyOptions: { daysOfWeek: [1, 3, 5] },
    };
    expect(repeat.weeklyOptions?.daysOfWeek).toEqual([1, 3, 5]);
  });
});
```

#### 3. 타입 가드 함수 테스트

```typescript
describe('Type Guard Functions', () => {
  describe('hasWeeklyOptions', () => {
    it('should return true for weekly repeat with weeklyOptions', () => {
      const repeat: RepeatInfo = {
        type: 'weekly',
        interval: 1,
        weeklyOptions: { daysOfWeek: [1, 3, 5] },
      };
      expect(hasWeeklyOptions(repeat)).toBe(true);
    });

    it('should return false for weekly repeat without weeklyOptions', () => {
      const repeat: RepeatInfo = { type: 'weekly', interval: 1 };
      expect(hasWeeklyOptions(repeat)).toBe(false);
    });

    it('should return false for non-weekly repeat', () => {
      const repeat: RepeatInfo = { type: 'daily', interval: 1 };
      expect(hasWeeklyOptions(repeat)).toBe(false);
    });
  });

  describe('isValidDaysOfWeek', () => {
    it('should return true for valid days array', () => {
      expect(isValidDaysOfWeek([1, 3, 5])).toBe(true);
      expect(isValidDaysOfWeek([0])).toBe(true);
      expect(isValidDaysOfWeek([0, 1, 2, 3, 4, 5, 6])).toBe(true);
    });

    it('should return false for invalid days array', () => {
      expect(isValidDaysOfWeek([])).toBe(false);
      expect(isValidDaysOfWeek([-1, 1])).toBe(false);
      expect(isValidDaysOfWeek([1, 7])).toBe(false);
      expect(isValidDaysOfWeek([1, 1, 3])).toBe(false); // 중복
    });
  });
});
```

### 통합 테스트 케이스

#### 1. 기존 코드 호환성 테스트

```typescript
describe('Backward Compatibility', () => {
  it('should not break existing RepeatInfo usage', () => {
    // 기존 방식으로 생성된 객체들이 정상 동작하는지 확인
    const existingRepeats: RepeatInfo[] = [
      { type: 'none', interval: 0 },
      { type: 'daily', interval: 1 },
      { type: 'weekly', interval: 1 },
      { type: 'monthly', interval: 1, endDate: '2024-12-31' },
    ];

    existingRepeats.forEach((repeat) => {
      expect(() => {
        // 기존 로직이 정상 동작하는지 확인
        const serialized = JSON.stringify(repeat);
        const parsed = JSON.parse(serialized) as RepeatInfo;
        expect(parsed.type).toBe(repeat.type);
      }).not.toThrow();
    });
  });
});
```

## 완료 정의 (Definition of Done)

### 기능 완료 기준

- [ ] WeeklyOptions 인터페이스가 정의됨
- [ ] RepeatInfo에 weeklyOptions 옵셔널 필드 추가됨
- [ ] 타입 가드 함수들이 구현됨 (선택사항)
- [ ] JSDoc 주석이 모든 새로운 타입에 추가됨

### 품질 기준

- [ ] 모든 단위 테스트가 통과함
- [ ] 통합 테스트가 통과함
- [ ] TypeScript 컴파일 오류 없음
- [ ] 기존 코드 호환성 검증 완료

### 문서화 기준

- [ ] 타입 정의에 JSDoc 주석 추가
- [ ] README 또는 아키텍처 문서 업데이트
- [ ] 예시 코드 작성

### 검토 기준

- [ ] 코드 리뷰 승인
- [ ] 타입 정의 설계 검토 완료
- [ ] 성능 영향 평가 완료

## 위험 요소 및 완화 전략

### 위험 요소

1. **기존 코드 호환성 깨짐**: weeklyOptions 추가로 인한 기존 코드 영향
2. **타입 복잡성 증가**: 새로운 타입으로 인한 이해도 저하
3. **성능 영향**: 타입 체킹 및 객체 생성 성능

### 완화 전략

1. **하위 호환성 보장**: 옵셔널 필드 사용, 기존 코드 무변경 원칙
2. **명확한 문서화**: JSDoc과 예시 코드로 이해도 향상
3. **점진적 적용**: 기존 함수는 유지하고 새로운 함수 별도 추가

## 다음 스토리와의 연계

이 스토리 완료 후:

- **스토리 1.2**: 새로운 타입을 사용한 날짜 계산 로직 구현
- **스토리 1.3**: WeeklyOptions를 활용한 UI 컴포넌트 개발

## 리뷰 체크리스트

### 코드 품질

- [ ] 타입 정의가 명확하고 일관성 있음
- [ ] JSDoc 주석이 충분히 작성됨
- [ ] 네이밍이 직관적이고 기존 규칙을 따름

### 기능성

- [ ] 모든 수락 기준이 충족됨
- [ ] 통합 검증이 통과됨
- [ ] 엣지 케이스가 고려됨

### 호환성

- [ ] 기존 코드가 변경 없이 동작함
- [ ] 타입 안정성이 유지됨
- [ ] 성능 영향이 최소화됨

---

이 스토리는 주간 반복 요일 선택 기능의 기반이 되는 타입 시스템을 구축하며, 기존 시스템과의 완전한 호환성을 보장합니다.

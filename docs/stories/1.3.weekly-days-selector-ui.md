# 스토리 1.3: WeeklyDaysSelector UI 컴포넌트 개발

## 스토리 개요

**As a** 사용자  
**I want** 주간 반복 선택 시 원하는 요일들을 체크박스로 선택할 수 있다  
**So that** 내가 원하는 특정 요일에만 반복 일정을 만들 수 있다

## 비즈니스 컨텍스트

### 현재 상태

- RepeatSection에 주간 반복 타입 선택만 가능
- 선택된 주간 반복은 매주 같은 요일에만 반복
- 복수 요일 선택 기능 없음

### 목표 상태

- 주간 반복 선택 시 요일 선택 UI 자동 표시
- 7개 요일 체크박스로 직관적 선택 인터페이스
- Material-UI 디자인 시스템과 완전 일치하는 스타일

### 사용자 시나리오

```
사용자가 "반복 유형"에서 "매주"를 선택
→ 요일 선택 체크박스 그룹이 나타남
→ 사용자가 "월", "수", "금" 체크박스 선택
→ "매주 월, 수, 금요일에 반복" 설정 완료
```

## 수락 기준

### AC1: WeeklyDaysSelector 컴포넌트 기본 구조

**Given** 주간 반복이 선택된 상태일 때  
**When** WeeklyDaysSelector 컴포넌트가 렌더링될 때  
**Then** 7개 요일 체크박스가 올바른 순서로 표시되어야 한다

**컴포넌트 시그니처:**

```typescript
interface WeeklyDaysSelectorProps {
  selectedDays: number[];
  onSelectionChange: (days: number[]) => void;
  disabled?: boolean;
}
```

**검증 기준:**

- [ ] 7개 체크박스가 일, 월, 화, 수, 목, 금, 토 순서로 표시됨
- [ ] 각 체크박스에 한국어 요일명 라벨 표시
- [ ] Material-UI Checkbox와 FormGroup 컴포넌트 사용
- [ ] selectedDays prop에 따라 체크 상태 표시

### AC2: 요일 선택 상태 관리

**Given** 사용자가 요일 체크박스를 클릭할 때  
**When** 체크박스 상태가 변경될 때  
**Then** onSelectionChange 콜백이 올바른 요일 배열과 함께 호출되어야 한다

**검증 기준:**

- [ ] 체크박스 클릭 시 해당 요일이 배열에 추가/제거됨
- [ ] 요일 배열은 항상 정렬된 상태로 유지됨 (오름차순)
- [ ] 중복 요일이 배열에 포함되지 않음
- [ ] 빈 배열도 정상적으로 처리됨

### AC3: 유효성 검증 및 오류 처리

**Given** 사용자가 요일 선택을 완료할 때  
**When** 최소 1개 요일이 선택되지 않은 경우  
**Then** 검증 오류 메시지가 표시되어야 한다

**검증 기준:**

- [ ] 선택된 요일이 없으면 "최소 1개 요일을 선택해주세요" 오류 표시
- [ ] 오류 상태에서 체크박스 스타일 변경 (빨간색 테두리)
- [ ] 요일 선택 시 오류 메시지 자동 제거
- [ ] error prop을 통한 외부 검증 오류 지원

### AC4: 접근성 및 키보드 네비게이션

**Given** 키보드 사용자가 컴포넌트에 접근할 때  
**When** Tab과 스페이스바를 사용할 때  
**Then** 모든 체크박스가 키보드로 조작 가능해야 한다

**검증 기준:**

- [ ] Tab 키로 체크박스 간 이동 가능
- [ ] 스페이스바로 체크박스 토글 가능
- [ ] 스크린 리더에서 요일명과 선택 상태 읽기 가능
- [ ] aria-label과 역할(role) 속성 적절히 설정
- [ ] 키보드 포커스 표시 명확함

### AC5: 반응형 디자인 및 스타일링

**Given** 다양한 화면 크기에서 컴포넌트가 표시될 때  
**When** 모바일과 데스크톱 환경에서 확인할 때  
**Then** 적절한 레이아웃으로 표시되어야 한다

**검증 기준:**

- [ ] 데스크톱: 7개 체크박스가 한 줄에 표시
- [ ] 모바일: 체크박스가 2-3줄로 자동 줄바꿈
- [ ] Material-UI 기본 간격과 일치하는 여백
- [ ] 기존 RepeatSection 스타일과 일관성 유지

## 통합 검증 기준

### IV1: RepeatSection UI 일관성

**검증 시나리오:**

- WeeklyDaysSelector가 RepeatSection 내에서 자연스럽게 통합
- 기존 필드들과 동일한 간격과 스타일 적용
- 전체 폼의 시각적 균형 유지

### IV2: 반응형 레이아웃 동작

**검증 기준:**

- 화면 크기 변경 시 레이아웃 자동 조정
- 터치 디바이스에서 체크박스 터치 영역 충분
- 확대/축소 시 텍스트 가독성 유지

### IV3: WCAG 2.1 AA 접근성 기준

**검증 기준:**

- 색상 대비 4.5:1 이상 유지
- 키보드만으로 모든 기능 사용 가능
- 스크린 리더에서 완전한 정보 제공

## 기술적 구현 요구사항

### 구현 파일

- **주 파일**: `src/components/WeeklyDaysSelector.tsx`
- **테스트 파일**: `src/__tests__/components/WeeklyDaysSelector.test.tsx`

### 컴포넌트 구현

#### 핵심 컴포넌트 구조

```typescript
import React from 'react';
import {
  FormControl,
  FormGroup,
  FormLabel,
  FormControlLabel,
  Checkbox,
  FormHelperText,
  Box,
  useTheme,
  useMediaQuery,
} from '@mui/material';

/**
 * 주간 반복 시 특정 요일들을 선택할 수 있는 체크박스 그룹 컴포넌트
 *
 * 선언적 특징:
 * - 요일 데이터와 UI를 명확히 분리
 * - 상태 관리를 상위 컴포넌트에 위임
 * - 접근성과 반응형 디자인을 내장
 */
export interface WeeklyDaysSelectorProps {
  /** 선택된 요일 배열 (0=일요일, 1=월요일, ..., 6=토요일) */
  selectedDays: number[];
  /** 요일 선택 변경 시 호출되는 콜백 함수 */
  onSelectionChange: (days: number[]) => void;
  /** 컴포넌트 비활성화 여부 */
  disabled?: boolean;
  /** 외부에서 전달되는 검증 오류 메시지 */
  error?: string;
  /** 접근성을 위한 레이블 ID */
  labelId?: string;
}

// 요일 정보 상수 (한국어 표시명과 숫자 매핑)
const WEEKDAYS = [
  { value: 0, label: '일', fullLabel: '일요일' },
  { value: 1, label: '월', fullLabel: '월요일' },
  { value: 2, label: '화', fullLabel: '화요일' },
  { value: 3, label: '수', fullLabel: '수요일' },
  { value: 4, label: '목', fullLabel: '목요일' },
  { value: 5, label: '금', fullLabel: '금요일' },
  { value: 6, label: '토', fullLabel: '토요일' },
] as const;

export const WeeklyDaysSelector: React.FC<WeeklyDaysSelectorProps> = ({
  selectedDays,
  onSelectionChange,
  disabled = false,
  error,
  labelId,
}) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  // 최소 1개 요일 선택 검증
  const hasValidation = selectedDays.length === 0;
  const showError = error || (hasValidation ? '최소 1개 요일을 선택해주세요' : '');

  /**
   * 요일 체크박스 변경 핸들러
   * 선택/해제에 따라 배열을 업데이트하고 정렬된 상태로 유지
   */
  const handleDayToggle = (dayValue: number) => {
    if (disabled) return;

    const newSelectedDays = selectedDays.includes(dayValue)
      ? selectedDays.filter((day) => day !== dayValue)
      : [...selectedDays, dayValue].sort();

    onSelectionChange(newSelectedDays);
  };

  return (
    <FormControl component="fieldset" fullWidth error={Boolean(showError)} disabled={disabled}>
      <FormLabel
        component="legend"
        id={labelId}
        sx={{
          marginBottom: 1,
          fontSize: theme.typography.body2.fontSize,
          fontWeight: theme.typography.fontWeightMedium,
        }}
      >
        반복 요일
      </FormLabel>

      <FormGroup
        aria-labelledby={labelId}
        sx={{
          flexDirection: isMobile ? 'column' : 'row',
          gap: isMobile ? 0.5 : 1,
          flexWrap: isMobile ? 'nowrap' : 'wrap',
        }}
      >
        {WEEKDAYS.map((weekday) => (
          <FormControlLabel
            key={weekday.value}
            control={
              <Checkbox
                checked={selectedDays.includes(weekday.value)}
                onChange={() => handleDayToggle(weekday.value)}
                disabled={disabled}
                size="small"
                inputProps={{
                  'aria-label': `${weekday.fullLabel} 선택`,
                }}
                sx={{
                  padding: theme.spacing(0.5),
                  '&.Mui-checked': {
                    color: theme.palette.primary.main,
                  },
                }}
              />
            }
            label={weekday.label}
            sx={{
              marginRight: isMobile ? 0 : 1,
              marginLeft: 0,
              minWidth: isMobile ? 'auto' : '60px',
              '& .MuiFormControlLabel-label': {
                fontSize: theme.typography.body2.fontSize,
                userSelect: 'none',
              },
            }}
          />
        ))}
      </FormGroup>

      {showError && <FormHelperText sx={{ marginTop: 1 }}>{showError}</FormHelperText>}
    </FormControl>
  );
};

/**
 * 선택된 요일들을 한국어 문자열로 변환하는 유틸리티 함수
 * @param selectedDays 선택된 요일 배열
 * @returns "월, 수, 금" 형태의 문자열
 */
export function formatSelectedDays(selectedDays: number[]): string {
  if (selectedDays.length === 0) return '';

  const dayLabels = selectedDays
    .sort()
    .map((day) => WEEKDAYS.find((wd) => wd.value === day)?.label)
    .filter(Boolean);

  return dayLabels.join(', ');
}

/**
 * 선택된 요일이 유효한지 검증하는 함수
 * @param selectedDays 선택된 요일 배열
 * @returns 유효성 검증 결과
 */
export function validateSelectedDays(selectedDays: number[]): {
  isValid: boolean;
  errorMessage?: string;
} {
  if (selectedDays.length === 0) {
    return {
      isValid: false,
      errorMessage: '최소 1개 요일을 선택해주세요',
    };
  }

  const hasInvalidDay = selectedDays.some((day) => day < 0 || day > 6);
  if (hasInvalidDay) {
    return {
      isValid: false,
      errorMessage: '유효하지 않은 요일이 선택되었습니다',
    };
  }

  return { isValid: true };
}
```

#### 스타일링 및 테마 적용

```typescript
// 커스텀 스타일 확장 (필요시)
const useWeeklyDaysSelectorStyles = () => {
  const theme = useTheme();

  return {
    container: {
      '& .MuiFormLabel-root': {
        color: theme.palette.text.primary,
        '&.Mui-focused': {
          color: theme.palette.primary.main,
        },
        '&.Mui-error': {
          color: theme.palette.error.main,
        },
      },
    },
    checkboxGroup: {
      '& .MuiCheckbox-root': {
        borderRadius: theme.shape.borderRadius,
        '&:hover': {
          backgroundColor: theme.palette.action.hover,
        },
      },
    },
    mobileLayout: {
      [theme.breakpoints.down('sm')]: {
        '& .MuiFormGroup-root': {
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fit, minmax(80px, 1fr))',
          gap: theme.spacing(1),
        },
      },
    },
  };
};
```

## 테스트 전략

### 단위 테스트 케이스

#### 1. 기본 렌더링 테스트

```typescript
import { render, screen, fireEvent } from '@testing-library/react';
import { WeeklyDaysSelector } from '../WeeklyDaysSelector';

describe('WeeklyDaysSelector', () => {
  const defaultProps = {
    selectedDays: [],
    onSelectionChange: jest.fn(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('기본 렌더링', () => {
    it('7개 요일 체크박스가 순서대로 표시됨', () => {
      render(<WeeklyDaysSelector {...defaultProps} />);

      const expectedDays = ['일', '월', '화', '수', '목', '금', '토'];
      expectedDays.forEach((day) => {
        expect(screen.getByLabelText(`${day}요일 선택`)).toBeInTheDocument();
      });
    });

    it('반복 요일 레이블이 표시됨', () => {
      render(<WeeklyDaysSelector {...defaultProps} />);
      expect(screen.getByText('반복 요일')).toBeInTheDocument();
    });

    it('선택된 요일에 따라 체크 상태 표시', () => {
      render(<WeeklyDaysSelector {...defaultProps} selectedDays={[1, 3, 5]} />);

      expect(screen.getByLabelText('월요일 선택')).toBeChecked();
      expect(screen.getByLabelText('수요일 선택')).toBeChecked();
      expect(screen.getByLabelText('금요일 선택')).toBeChecked();
      expect(screen.getByLabelText('일요일 선택')).not.toBeChecked();
    });
  });

  describe('상호작용 테스트', () => {
    it('체크박스 클릭 시 onSelectionChange 호출', () => {
      const mockOnChange = jest.fn();
      render(<WeeklyDaysSelector {...defaultProps} onSelectionChange={mockOnChange} />);

      fireEvent.click(screen.getByLabelText('월요일 선택'));
      expect(mockOnChange).toHaveBeenCalledWith([1]);
    });

    it('이미 선택된 요일 클릭 시 선택 해제', () => {
      const mockOnChange = jest.fn();
      render(
        <WeeklyDaysSelector
          {...defaultProps}
          selectedDays={[1, 3]}
          onSelectionChange={mockOnChange}
        />
      );

      fireEvent.click(screen.getByLabelText('월요일 선택'));
      expect(mockOnChange).toHaveBeenCalledWith([3]);
    });

    it('복수 요일 선택 시 정렬된 배열 반환', () => {
      const mockOnChange = jest.fn();
      render(
        <WeeklyDaysSelector
          {...defaultProps}
          selectedDays={[5, 1]}
          onSelectionChange={mockOnChange}
        />
      );

      fireEvent.click(screen.getByLabelText('수요일 선택'));
      expect(mockOnChange).toHaveBeenCalledWith([1, 3, 5]);
    });

    it('disabled 상태에서 클릭 무시', () => {
      const mockOnChange = jest.fn();
      render(
        <WeeklyDaysSelector {...defaultProps} disabled={true} onSelectionChange={mockOnChange} />
      );

      fireEvent.click(screen.getByLabelText('월요일 선택'));
      expect(mockOnChange).not.toHaveBeenCalled();
    });
  });

  describe('유효성 검증', () => {
    it('요일이 선택되지 않으면 오류 메시지 표시', () => {
      render(<WeeklyDaysSelector {...defaultProps} selectedDays={[]} />);
      expect(screen.getByText('최소 1개 요일을 선택해주세요')).toBeInTheDocument();
    });

    it('외부 오류 메시지 표시', () => {
      render(<WeeklyDaysSelector {...defaultProps} error="사용자 정의 오류" />);
      expect(screen.getByText('사용자 정의 오류')).toBeInTheDocument();
    });

    it('요일이 선택되면 오류 메시지 숨김', () => {
      render(<WeeklyDaysSelector {...defaultProps} selectedDays={[1]} />);
      expect(screen.queryByText('최소 1개 요일을 선택해주세요')).not.toBeInTheDocument();
    });
  });
});
```

#### 2. 접근성 테스트

```typescript
describe('접근성', () => {
  it('키보드 네비게이션 지원', () => {
    render(<WeeklyDaysSelector {...defaultProps} />);

    const firstCheckbox = screen.getByLabelText('일요일 선택');
    firstCheckbox.focus();
    expect(firstCheckbox).toHaveFocus();

    // Tab으로 다음 체크박스로 이동
    fireEvent.keyDown(firstCheckbox, { key: 'Tab' });
    expect(screen.getByLabelText('월요일 선택')).toHaveFocus();
  });

  it('스페이스바로 체크박스 토글', () => {
    const mockOnChange = jest.fn();
    render(<WeeklyDaysSelector {...defaultProps} onSelectionChange={mockOnChange} />);

    const checkbox = screen.getByLabelText('월요일 선택');
    checkbox.focus();
    fireEvent.keyDown(checkbox, { key: ' ' });
    expect(mockOnChange).toHaveBeenCalledWith([1]);
  });

  it('aria-label 올바르게 설정', () => {
    render(<WeeklyDaysSelector {...defaultProps} labelId="test-label" />);

    const group = screen.getByRole('group');
    expect(group).toHaveAttribute('aria-labelledby', 'test-label');
  });
});
```

#### 3. 유틸리티 함수 테스트

```typescript
import { formatSelectedDays, validateSelectedDays } from '../WeeklyDaysSelector';

describe('formatSelectedDays', () => {
  it('선택된 요일을 한국어 문자열로 변환', () => {
    expect(formatSelectedDays([1, 3, 5])).toBe('월, 수, 금');
  });

  it('빈 배열에 대해 빈 문자열 반환', () => {
    expect(formatSelectedDays([])).toBe('');
  });

  it('정렬되지 않은 배열도 올바르게 처리', () => {
    expect(formatSelectedDays([5, 1, 3])).toBe('월, 수, 금');
  });
});

describe('validateSelectedDays', () => {
  it('빈 배열에 대해 오류 반환', () => {
    const result = validateSelectedDays([]);
    expect(result.isValid).toBe(false);
    expect(result.errorMessage).toBe('최소 1개 요일을 선택해주세요');
  });

  it('유효한 요일 배열에 대해 성공 반환', () => {
    const result = validateSelectedDays([1, 3, 5]);
    expect(result.isValid).toBe(true);
    expect(result.errorMessage).toBeUndefined();
  });

  it('유효하지 않은 요일에 대해 오류 반환', () => {
    const result = validateSelectedDays([1, 7, 5]);
    expect(result.isValid).toBe(false);
    expect(result.errorMessage).toBe('유효하지 않은 요일이 선택되었습니다');
  });
});
```

### 통합 테스트 케이스

#### 1. RepeatSection과의 통합 테스트

```typescript
describe('RepeatSection 통합', () => {
  it('RepeatSection에서 WeeklyDaysSelector 렌더링', () => {
    // RepeatSection에 WeeklyDaysSelector가 올바르게 통합되는지 테스트
    // 별도의 통합 테스트 파일에서 구현
  });
});
```

#### 2. 반응형 디자인 테스트

```typescript
describe('반응형 디자인', () => {
  it('모바일 화면에서 세로 배치', () => {
    // viewport 크기를 모바일로 설정
    Object.defineProperty(window, 'innerWidth', {
      writable: true,
      configurable: true,
      value: 400,
    });

    render(<WeeklyDaysSelector {...defaultProps} />);

    // CSS 미디어 쿼리 테스트는 실제 환경에서 확인
    // 여기서는 렌더링 오류가 없는지만 확인
    expect(screen.getByText('반복 요일')).toBeInTheDocument();
  });
});
```

## 완료 정의 (Definition of Done)

### 기능 완료 기준

- [ ] WeeklyDaysSelector 컴포넌트 구현 완료
- [ ] formatSelectedDays, validateSelectedDays 유틸리티 함수 구현
- [ ] TypeScript 타입 정의 완료
- [ ] 모든 props 인터페이스 정의

### 품질 기준

- [ ] 모든 단위 테스트 통과 (95% 이상 커버리지)
- [ ] 접근성 테스트 통과
- [ ] 스토리북 스토리 작성 (선택사항)
- [ ] 크로스 브라우저 테스트 완료

### 디자인 기준

- [ ] Material-UI 디자인 시스템 준수
- [ ] 반응형 디자인 구현
- [ ] 다크/라이트 테마 지원
- [ ] 기존 RepeatSection과 시각적 일관성

### 접근성 기준

- [ ] WCAG 2.1 AA 기준 충족
- [ ] 키보드 네비게이션 완전 지원
- [ ] 스크린 리더 호환성
- [ ] 색상 대비 4.5:1 이상

### 문서화 기준

- [ ] 컴포넌트 JSDoc 주석 완성
- [ ] 사용 예시 코드 작성
- [ ] Props 문서화 완료

## 위험 요소 및 완화 전략

### 위험 요소

1. **복잡한 상태 관리**: 7개 체크박스의 개별 상태 관리
2. **접근성 구현**: 키보드 네비게이션과 스크린 리더 지원
3. **반응형 레이아웃**: 다양한 화면 크기에서의 일관된 UX

### 완화 전략

1. **단순한 데이터 구조**: 숫자 배열로 상태 단순화
2. **Material-UI 활용**: 검증된 접근성 컴포넌트 사용
3. **점진적 구현**: 데스크톱 → 모바일 순서로 구현

## 다음 스토리와의 연계

이 스토리 완료 후:

- **스토리 1.4**: RepeatSection에 WeeklyDaysSelector 통합
- **스토리 1.5**: 전체 UI 플로우 통합 테스트

## 리뷰 체크리스트

### UI/UX 품질

- [ ] 직관적인 사용자 인터페이스
- [ ] 일관된 시각적 디자인
- [ ] 터치 친화적인 크기 (최소 44px)

### 코드 품질

- [ ] 선언적 컴포넌트 구조
- [ ] 재사용 가능한 설계
- [ ] 타입 안전성 보장

### 성능

- [ ] 불필요한 리렌더링 방지
- [ ] 메모리 누수 없음
- [ ] 빠른 응답 시간

---

이 스토리는 주간 반복 요일 선택 기능의 핵심 UI 컴포넌트를 구현하며, 사용자에게 직관적이고 접근성 높은 인터페이스를 제공합니다.

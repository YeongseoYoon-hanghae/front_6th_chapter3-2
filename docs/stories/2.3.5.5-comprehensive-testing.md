# Story 2.3.5.5: 반복 일정 단일 수정 종합 테스트

## Status

Ready for Development

## Story

**As a** 개발팀,  
**I want** 반복 일정 단일 수정 기능의 모든 시나리오에 대한 포괄적인 테스트를,  
**so that** 기능의 안정성과 신뢰성을 보장할 수 있다.

## Problem Statement

반복 일정 단일 수정 기능은 복잡한 상태 관리와 다양한 사용자 시나리오를 포함하므로:

1. **다양한 반복 유형 처리** - 매일, 매주, 매월 등 모든 반복 유형 검증 필요
2. **복잡한 사용자 플로우** - 폼 로딩 → 수정 → 제출의 전체 흐름 검증
3. **에러 시나리오 처리** - 네트워크 오류, 유효성 검사 실패 등
4. **통합 테스트 필요** - 개별 컴포넌트뿐만 아니라 전체 시스템 검증

## Acceptance Criteria

1. **단위 테스트 커버리지** - 모든 핵심 함수와 훅에 대한 테스트
2. **컴포넌트 테스트** - UI 컴포넌트의 상호작용 테스트
3. **통합 테스트** - 전체 사용자 플로우 E2E 테스트
4. **에러 시나리오 테스트** - 예외 상황 처리 검증
5. **성능 테스트** - 대량 데이터에서의 동작 확인

## Test Strategy

### 1. 단위 테스트 (Unit Tests)

#### useEditingState 훅 테스트

```typescript
// src/hooks/__tests__/useEditingState.test.ts
describe('useEditingState', () => {
  test('초기 상태가 올바르게 설정됨', () => {
    const { result } = renderHook(() => useEditingState());

    expect(result.current.editingEvent).toBe(null);
    expect(result.current.isEditing).toBe(false);
    expect(result.current.isSingleEdit).toBe(false);
  });

  test('startSingleEdit 호출 시 단일 수정 모드로 전환됨', () => {
    const { result } = renderHook(() => useEditingState());
    const mockEvent = createMockRecurringEvent();

    act(() => {
      result.current.startSingleEdit(mockEvent);
    });

    expect(result.current.editingEvent).toBe(mockEvent);
    expect(result.current.isEditing).toBe(true);
    expect(result.current.isSingleEdit).toBe(true);
  });

  test('stopEditing 호출 시 모든 상태가 초기화됨', () => {
    const { result } = renderHook(() => useEditingState());
    const mockEvent = createMockRecurringEvent();

    act(() => {
      result.current.startSingleEdit(mockEvent);
    });

    act(() => {
      result.current.stopEditing();
    });

    expect(result.current.editingEvent).toBe(null);
    expect(result.current.isEditing).toBe(false);
    expect(result.current.isSingleEdit).toBe(false);
  });
});
```

#### convertToSingleEvent 함수 테스트

```typescript
// src/utils/__tests__/recurringUtils.test.ts
describe('convertToSingleEvent', () => {
  test('매주 반복 일정이 단일 일정으로 변환됨', () => {
    const weeklyEvent = {
      id: '1',
      title: '팀 회의',
      repeat: {
        id: 'repeat-1',
        type: 'weekly' as RepeatType,
        interval: 1,
        endDate: '2024-12-31',
      },
    };

    const result = convertToSingleEvent(weeklyEvent);

    expect(result.repeat.type).toBe('none');
    expect(result.repeat.interval).toBe(0);
    expect(result.repeat.id).toBeUndefined();
    expect(result.title).toBe('팀 회의');
  });

  test('매월 반복 일정이 단일 일정으로 변환됨', () => {
    const monthlyEvent = createMockEvent({
      repeat: { type: 'monthly', interval: 2 },
    });

    const result = convertToSingleEvent(monthlyEvent);

    expect(result.repeat.type).toBe('none');
    expect(result.repeat.interval).toBe(0);
  });
});
```

### 2. 컴포넌트 테스트 (Component Tests)

#### EventForm 컴포넌트 테스트

```typescript
// src/components/__tests__/EventForm.test.tsx
describe('EventForm - 단일 수정 모드', () => {
  test('단일 수정 모드에서 안내 메시지가 표시됨', () => {
    render(<EventForm editingEvent={mockRecurringEvent} isSingleEdit={true} isRepeating={true} />);

    expect(screen.getByText('이 일정만 수정')).toBeInTheDocument();
    expect(screen.getByText(/반복 일정에서 이 날짜의 일정만 수정됩니다/)).toBeInTheDocument();
  });

  test('반복 설정 필드가 시각적으로 구분됨', () => {
    render(<EventForm editingEvent={mockRecurringEvent} isSingleEdit={true} isRepeating={true} />);

    const repeatSection = screen.getByText(/원본 반복 설정을 참고용으로/).closest('div');
    expect(repeatSection).toHaveClass('single-edit-mode');
  });

  test('저장 버튼 텍스트가 "이 일정만 저장"으로 변경됨', () => {
    render(<EventForm editingEvent={mockRecurringEvent} isSingleEdit={true} />);

    expect(screen.getByText('이 일정만 저장')).toBeInTheDocument();
  });
});
```

#### RecurringEditDialog 컴포넌트 테스트

```typescript
// src/components/__tests__/RecurringEditDialog.test.tsx
describe('RecurringEditDialog', () => {
  test('다이얼로그가 올바르게 렌더링됨', () => {
    const mockEvent = createMockRecurringEvent({
      title: '팀 회의',
      date: '2024-12-20',
    });

    render(
      <RecurringEditDialog
        isOpen={true}
        targetEvent={mockEvent}
        onEditSingle={jest.fn()}
        onCancel={jest.fn()}
      />
    );

    expect(screen.getByText('반복 일정 수정')).toBeInTheDocument();
    expect(screen.getByText('"팀 회의" 반복 일정을 어떻게 수정하시겠습니까?')).toBeInTheDocument();
  });

  test('"이 일정만 수정" 버튼 클릭 시 콜백이 호출됨', () => {
    const onEditSingle = jest.fn();

    render(
      <RecurringEditDialog
        isOpen={true}
        targetEvent={mockRecurringEvent}
        onEditSingle={onEditSingle}
        onCancel={jest.fn()}
      />
    );

    fireEvent.click(screen.getByText('이 일정만 수정'));
    expect(onEditSingle).toHaveBeenCalledTimes(1);
  });
});
```

### 3. 통합 테스트 (Integration Tests)

#### 전체 단일 수정 플로우 테스트

```typescript
// src/__tests__/integration/singleEditFlow.test.tsx
describe('반복 일정 단일 수정 통합 테스트', () => {
  beforeEach(() => {
    // Mock API 설정
    setupMockAPI();
  });

  test('매주 반복 일정 단일 수정 전체 플로우', async () => {
    const weeklyEvent = createMockRecurringEvent({
      title: '팀 회의',
      date: '2024-12-19',
      repeat: { type: 'weekly', interval: 1 },
    });

    render(<App />);

    // 1. 반복 일정 클릭
    const eventElement = screen.getByText('팀 회의');
    fireEvent.click(eventElement);

    // 2. "이 일정만 수정" 선택
    await waitFor(() => {
      expect(screen.getByText('반복 일정 수정')).toBeInTheDocument();
    });

    fireEvent.click(screen.getByText('이 일정만 수정'));

    // 3. 폼에서 원본 반복 정보 확인
    await waitFor(() => {
      expect(screen.getByLabelText('반복 일정')).toBeChecked();
      expect(screen.getByDisplayValue('매주')).toBeInTheDocument();
    });

    // 4. 제목 수정
    const titleInput = screen.getByLabelText('제목');
    fireEvent.change(titleInput, { target: { value: '긴급 팀 회의' } });

    // 5. 저장
    fireEvent.click(screen.getByText('이 일정만 저장'));

    // 6. 성공 메시지 확인
    await waitFor(() => {
      expect(screen.getByText(/긴급 팀 회의.*단일 일정으로 수정되었습니다/)).toBeInTheDocument();
    });

    // 7. API 호출 확인
    expect(mockCreateEvent).toHaveBeenCalledWith(
      expect.objectContaining({
        title: '긴급 팀 회의',
        repeat: { type: 'none', interval: 0 },
      })
    );
  });

  test('반복 설정 해제 시나리오', async () => {
    render(<App />);

    // 반복 일정 단일 수정 모드 진입
    await enterSingleEditMode('매일 운동');

    // 반복 설정 해제
    const repeatCheckbox = screen.getByLabelText('반복 일정');
    fireEvent.click(repeatCheckbox);

    // 반복 설정 필드들이 숨겨짐
    expect(screen.queryByLabelText('반복 유형')).not.toBeInTheDocument();

    // 저장
    fireEvent.click(screen.getByText('이 일정만 저장'));

    // 단일 일정으로 저장 확인
    await waitFor(() => {
      expect(mockCreateEvent).toHaveBeenCalledWith(
        expect.objectContaining({
          repeat: { type: 'none', interval: 0 },
        })
      );
    });
  });
});
```

### 4. 에러 시나리오 테스트

```typescript
// src/__tests__/error-scenarios/singleEditErrors.test.tsx
describe('단일 수정 에러 시나리오', () => {
  test('API 호출 실패 시 적절한 에러 메시지 표시', async () => {
    // API 실패 모킹
    mockCreateEvent.mockRejectedValueOnce(new Error('Network Error'));

    render(<App />);

    await enterSingleEditMode('팀 회의');
    fireEvent.click(screen.getByText('이 일정만 저장'));

    await waitFor(() => {
      expect(screen.getByText('단일 일정 수정에 실패했습니다.')).toBeInTheDocument();
    });
  });

  test('유효성 검사 실패 시 저장 안됨', async () => {
    render(<App />);

    await enterSingleEditMode('팀 회의');

    // 제목을 비움
    const titleInput = screen.getByLabelText('제목');
    fireEvent.change(titleInput, { target: { value: '' } });

    fireEvent.click(screen.getByText('이 일정만 저장'));

    // API 호출되지 않음
    expect(mockCreateEvent).not.toHaveBeenCalled();

    // 에러 메시지 확인
    expect(screen.getByText('제목을 입력해주세요.')).toBeInTheDocument();
  });
});
```

### 5. 성능 테스트

```typescript
// src/__tests__/performance/singleEdit.test.tsx
describe('단일 수정 성능 테스트', () => {
  test('대량의 반복 일정이 있어도 단일 수정이 빠르게 동작함', async () => {
    // 100개의 반복 일정 생성
    const manyEvents = Array.from({ length: 100 }, (_, i) =>
      createMockRecurringEvent({ id: `event-${i}` })
    );

    const startTime = performance.now();

    render(<App initialEvents={manyEvents} />);

    await enterSingleEditMode('event-50');
    fireEvent.click(screen.getByText('이 일정만 저장'));

    const endTime = performance.now();
    const duration = endTime - startTime;

    // 2초 이내에 완료되어야 함
    expect(duration).toBeLessThan(2000);
  });
});
```

## Implementation Tasks

- [ ] **단위 테스트 작성**

  - [ ] `useEditingState` 훅 테스트 완성
  - [ ] `convertToSingleEvent` 함수 테스트 완성
  - [ ] 관련 유틸리티 함수들 테스트

- [ ] **컴포넌트 테스트 작성**

  - [ ] `EventForm` 단일 수정 모드 테스트
  - [ ] `RecurringEditDialog` 상호작용 테스트
  - [ ] UI 상태 변화 테스트

- [ ] **통합 테스트 작성**

  - [ ] 전체 사용자 플로우 E2E 테스트
  - [ ] 다양한 반복 유형별 시나리오 테스트
  - [ ] 상태 전환 테스트

- [ ] **에러 시나리오 테스트**

  - [ ] API 실패 상황 테스트
  - [ ] 유효성 검사 실패 테스트
  - [ ] 네트워크 오류 처리 테스트

- [ ] **성능 테스트 작성**
  - [ ] 대량 데이터 처리 성능 테스트
  - [ ] 메모리 누수 검사
  - [ ] 렌더링 성능 측정

## Test Coverage Goals

- **단위 테스트 커버리지:** 95% 이상
- **컴포넌트 테스트 커버리지:** 90% 이상
- **통합 테스트:** 주요 사용자 플로우 100% 커버
- **에러 시나리오:** 예상 가능한 모든 에러 상황 커버

## Definition of Done

- [ ] 모든 단위 테스트 작성 및 통과
- [ ] 모든 컴포넌트 테스트 작성 및 통과
- [ ] 핵심 통합 테스트 작성 및 통과
- [ ] 에러 시나리오 테스트 작성 및 통과
- [ ] 성능 테스트 기준 만족
- [ ] 코드 커버리지 목표 달성
- [ ] CI/CD 파이프라인에서 모든 테스트 통과

## Dependencies

**전제 조건:**

- Story 2.3.5.1~2.3.5.4 모든 기능 구현 완료
- 테스트 환경 및 Mock 데이터 설정 완료

**테스트 도구:**

- Jest, React Testing Library
- MSW (Mock Service Worker)
- Performance API

## Estimated Effort

**단위 테스트:** 4-6시간  
**컴포넌트 테스트:** 4-6시간  
**통합 테스트:** 6-8시간  
**에러/성능 테스트:** 3-4시간  
**총 예상 시간:** 17-24시간

## Notes

이 스토리는 반복 일정 단일 수정 기능의 품질을 보장하는 중요한 테스트 작업입니다. 포괄적인 테스트를 통해 사용자에게 안정적인 기능을 제공할 수 있습니다.
